<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Article Notes</title>
    <link rel="stylesheet" href="project/assets/css/style.css" />
    <script src="project/assets/js/dataService.js"></script>
    <script src="project/assets/js/toast.js"></script>
    <style>
      :root {
        --radius: 12px;
        --gap: 12px;
        --brand: #10b981;     /* verde acqua */
        --brand-2: #06b6d4;   /* azzurro */
        --brand-3: #a7f3d0;   /* verde chiaro */
        --bg: #f8fafc;
        --surface: #ffffff;
        --border-color: #e2e8f0;
        --text: #0f172a;
        --muted: #64748b;
        --chip-bg: #ecfeff;
        --chip-border: #cffafe;

        /* Libreria */
        --book-shadow: rgba(0,0,0,.15);
        --shelf-wood-1: #d8c0a8;
        --shelf-wood-2: #c1a186;
      }

      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        line-height: 1.45;
        margin: 2rem;
        color: var(--text);
        background: var(--bg);
      }

      button, .btn {
        font-size: 14px;
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--surface);
        cursor: pointer;
        transition: background 0.15s ease, transform 0.05s ease;
      }
      button:hover, .btn:hover { background: #f1f5f9; }
      button:active, .btn:active { transform: translateY(1px); }
      .btn.primary { background: var(--brand); color: #fff; border-color: var(--brand); }
      .btn.primary:hover { filter: brightness(0.98); }

      .header { margin-bottom: 1rem; }

      /* Filters (immutati) */
      .filters { margin-top: 16px; padding: 12px; border: 1px solid #e5e7eb; border-radius: 12px; background: #fafafa; }
      .filters h2 { margin: 0; font-size: 16px; }
      .filters-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
      .filters-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
      .filters .row { display: grid; gap: 8px; }
      .filters label { font-size: 12px; color: #374151; }
      .filters input[type="search"] { padding: 8px 10px; border: 1px solid #d0d0d0; border-radius: 8px; font-size: 14px; }
      .filters-actions { display: flex; justify-content: flex-end; }
      .filters.collapsed .filters-grid { display: none; }
      .dropdown { position: relative; display: inline-block; }
      .dropdown-menu { position: absolute; z-index: 20; right: 0; margin-top: 6px; min-width: 280px; padding: 10px; border: 1px solid #e5e7eb; border-radius: 10px; background: #fff; box-shadow: 0 10px 30px rgba(0,0,0,0.08); display: none; }
      .dropdown.open .dropdown-menu { display: block; }
      .dropdown .row { margin-bottom: 6px; }
      .dropdown select[multiple] { min-height: 100px; }
      .filters-chips { display: flex; flex-wrap: wrap; gap: 6px; }
      .chip.rem { cursor: pointer; }

      /* ====== Libreria 3D (sostituisce la griglia delle card) ====== */
      #notesSection { margin-top: 16px; }
      .bookcase {
        position: relative;
        border: 1px solid var(--border-color);
        border-radius: 14px;
        background:
          linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.95)),
          repeating-linear-gradient(90deg, #ffffff 0 32px, #fafafa 32px 64px);
        padding: 18px 16px;
      }
      .shelf {
        position: relative;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: flex-end;
        padding: 18px 8px 26px 8px; /* spazio per bordo ripiano */
        border-radius: 10px;
        margin-bottom: 10px;
      }
      .shelf::after {
        content: "";
        position: absolute;
        left: 6px; right: 6px; bottom: 6px; height: 14px;
        border-radius: 8px;
        background:
          linear-gradient(180deg, var(--shelf-wood-1), var(--shelf-wood-2));
        box-shadow: 0 6px 14px rgba(0,0,0,0.08) inset, 0 2px 10px rgba(0,0,0,0.12);
      }

      .book {
        --h: 140px;     /* altezza dorso */
        --w: 28px;      /* spessore */
        --cover: #bbe7ff;
        position: relative;
        width: var(--w);
        height: var(--h);
        transform-style: preserve-3d;
        filter: drop-shadow(0 5px 8px var(--book-shadow));
        cursor: pointer;
        border-radius: 6px;
      }
      .book:focus { outline: 2px solid #94a3b8; outline-offset: 2px; }
      .book:hover { transform: translateY(-2px) rotateZ(-.4deg); }

      .spine {
        position: absolute; inset: 0;
        border-radius: 6px;
        background:
          linear-gradient(180deg, rgba(255,255,255,.25), transparent 60%),
          linear-gradient(90deg, rgba(0,0,0,.25), transparent 20%, rgba(255,255,255,.3) 45%, transparent 60%, rgba(0,0,0,.25) 85%),
          var(--cover);
        display: flex; align-items: center; justify-content: center;
        padding: 6px;
        box-shadow: inset 0 1px 0 rgba(255,255,255,.4), inset 0 -1px 0 rgba(0,0,0,.25);
      }
      .spine .title {
        writing-mode: vertical-rl;
        transform: rotate(180deg);
        font-weight: 700;
        letter-spacing: 1.1px;
        text-transform: uppercase;
        color: #0f172a;
        line-height: 1;
        max-height: 100%;
        overflow: hidden;
        word-break: break-word;
        text-shadow: 0 1px 0 rgba(255,255,255,.6);
        /* dimensione gestita via JS */
      }
      .book::before{
        content:""; position:absolute; right:-4px; top:2px; bottom:2px; width:4px; border-radius:2px;
        background: repeating-linear-gradient(180deg, #f3f4f6 0 2px, #e5e7eb 2px 4px);
        box-shadow: inset 0 0 1px rgba(0,0,0,.25);
      }

      .stick-note{
        position:absolute; top:4px; right:-10px;
        background:#facc15; color:#1e1e1e; font-size:11px; font-weight:800;
        padding:2px 5px; border-radius:3px; transform:rotate(8deg);
        border:1px solid rgba(0,0,0,.2); box-shadow:0 2px 6px rgba(0,0,0,.18);
      }

      .book-tooltip{
        position:absolute; left:50%; bottom:calc(100% + 10px);
        transform: translateX(-50%) translateY(8px);
        background: #0b0d12; color:#e5e7eb;
        border:1px solid rgba(255,255,255,.08);
        padding:6px 8px; border-radius:8px; font-size:12px; font-weight:600;
        white-space:nowrap; opacity:0; pointer-events:none; transition: all .18s ease;
        box-shadow: 0 8px 24px rgba(0,0,0,.18);
      }
      .book-tooltip::after{
        content:""; position:absolute; left:50%; top:100%;
        transform: translateX(-50%);
        border:6px solid transparent; border-top-color:#0b0d12;
      }
      .book:hover .book-tooltip{ opacity:1; transform: translateX(-50%) translateY(0); }

      /* Mobile */
      @media (max-width: 640px) {
        body { margin: 1rem; }
        .book { --h: 120px; --w: 24px; }
      }
    </style>
  </head>
  <body>
    <h1 class="header">Article Notes</h1>
    <div class="header" style="margin-top:-0.5rem;">
      <div></div>
      <div>
        <a class="btn" href="add-doi.html">Aggiungi DOI</a>
        <a class="btn" href="variabili.html">Variabili</a>
        <a class="btn" href="variabili-tabella.html">Tabella variabili</a>
        <a class="btn" href="grafici.html">Tabella grafici</a>
      </div>
    </div>

    <section class="filters" aria-label="Filtri">
      <div class="filters-header">
        <h2>Filtri</h2>
        <button id="filtersCollapseBtn" class="collapse-btn" aria-expanded="true" title="Comprimi/Espandi">▾</button>
      </div>
      <div class="filters-grid">
        <div class="row">
          <label for="filterTitle">Titolo articolo</label>
          <input id="filterTitle" type="search" placeholder="Cerca per titolo..." />
        </div>
        <div class="row">
          <label>Filtri selezionati</label>
          <div id="filtersChips" class="filters-chips"></div>
        </div>
        <div class="row">
          <label>Filtri avanzati</label>
          <div class="dropdown" id="advDropdown">
            <button id="advBtn" class="btn" type="button">Seleziona…</button>
            <div id="advMenu" class="dropdown-menu">
              <div class="row">
                <label for="typeMulti">Types</label>
                <select id="typeMulti" multiple></select>
              </div>
              <div class="row">
                <label for="tagsMulti">Tags</label>
                <select id="tagsMulti" multiple></select>
              </div>
              <div class="row">
                <label for="animalsMulti">Animals</label>
                <select id="animalsMulti" multiple></select>
              </div>
              <div class="row">
                <label for="methodsMulti">Methods</label>
                <select id="methodsMulti" multiple></select>
              </div>
              <div class="filters-actions">
                <button id="applyAdv" class="btn primary" type="button">Applica</button>
                <button id="clearAdv" class="btn" type="button">Pulisci</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="notesSection" aria-label="Note salvate" style="margin-top:16px;">
      <div id="notesContainer"></div>
    </section>

    <script>
      (function () {
        const notesContainer = document.getElementById('notesContainer');
        const filterTitleEl = document.getElementById('filterTitle');
        const filtersChips = document.getElementById('filtersChips');
        const filtersEl = document.querySelector('section.filters');
        const filtersCollapseBtn = document.getElementById('filtersCollapseBtn');
        const advDropdown = document.getElementById('advDropdown');
        const advBtn = document.getElementById('advBtn');
        const advMenu = document.getElementById('advMenu');
        const typeMulti = document.getElementById('typeMulti');
        const tagsMulti = document.getElementById('tagsMulti');
        const animalsMulti = document.getElementById('animalsMulti');
        const methodsMulti = document.getElementById('methodsMulti');
        const applyAdv = document.getElementById('applyAdv');
        const clearAdv = document.getElementById('clearAdv');

        let db = {};
        const TYPE_COLOR_KEY = 'typeColors.v1';
        const FILTERS_COLLAPSE_KEY = 'filtersCollapsed.v1';
        let facets = { types: [], tags: [], animals: [], methods: [] };
        let filters = { title: '', types: new Set(), tags: new Set(), animals: new Set(), methods: new Set() };

        /* ===== util originali (immutati/riusati) ===== */
        function loadTypeColors() {
          try { return JSON.parse(localStorage.getItem(TYPE_COLOR_KEY) || '{}') || {}; } catch (_) { return {}; }
        }
        function saveTypeColors(map) {
          try { localStorage.setItem(TYPE_COLOR_KEY, JSON.stringify(map)); } catch (_) {}
        }
        function randomPastel() {
          const h = Math.floor(Math.random() * 360);
          const s = 70; // percent
          const l = 88; // percent
          return `hsl(${h} ${s}% ${l}%)`;
        }
        function getTypeColor(type) {
          if (!type) return '#d1d5db';
          const map = loadTypeColors();
          if (!map[type]) {
            map[type] = randomPastel();
            saveTypeColors(map);
          }
          return map[type];
        }

        function clampImportanza(v){
          const n = parseInt(v, 10);
          if (isNaN(n)) return 1;
          return Math.max(1, Math.min(10, n));
        }
        function importanceToBg(val){
          const v = clampImportanza(val);
          const hue = 55 - (v - 1) * (55 / 9); // yellow->red
          const sat = 78 + (v - 1) * (20 / 9); // 78%->~98%
          const light = 96 - (v - 1) * (9 / 9); // 96%->87%
          return `hsl(${hue.toFixed(1)} ${sat.toFixed(1)}% ${light.toFixed(1)}%)`;
        }

        function formatNoteText(raw) {
          if (raw == null) return '';
          const normalized = String(raw).replace(/\r\n/g, '\n');
          const trimmed = normalized.trim();
          if (!trimmed) return '';
          const startsWithBullet = /^-\s*/.test(trimmed);
          const hasLineBullets = /\n\s*-\s*/.test(trimmed);
          if (startsWithBullet || hasLineBullets) {
            const parts = trimmed.split(/\s*-\s+/).map(part => part.trim()).filter(Boolean);
            if (parts.length > 1) return parts.map(part => `- ${part}`).join('\n');
          }
          return trimmed;
        }

        function loadFiltersCollapsed() {
          try { return localStorage.getItem(FILTERS_COLLAPSE_KEY) === '1'; } catch (_) { return false; }
        }
        function saveFiltersCollapsed(v) {
          try { localStorage.setItem(FILTERS_COLLAPSE_KEY, v ? '1' : '0'); } catch (_) {}
        }

        function getTitle(entry) {
          if (!entry) return '';
          const t = entry.title;
          if (Array.isArray(t) && t.length) return t.join(' — ');
          if (typeof t === 'string') return t;
          return '';
        }

        function detailsText(entry) {
          const d = (entry && entry.dettagli) || {};
          const parts = [];
          const push = (v) => { if (v != null && String(v).trim()) parts.push(String(v)); };
          // General
          push(d.ecosistema); push(d.background); push(d.main_objective); push(d.sub_objective); push(d.biological_organization);
          // Temporal
          if (d.temporal_scale) { push(d.temporal_scale.start); push(d.temporal_scale.end); push(d.temporal_scale.resolution); }
          // Spatial
          if (d.spatial_scale) { push(d.spatial_scale.place); push(d.spatial_scale.lat); push(d.spatial_scale.long); push(d.spatial_scale.description); }
          // Methods
          const mm = d.methods;
          (Array.isArray(mm) ? mm : (mm ? [String(mm)] : [])).forEach(push);
          // Variables
          if (Array.isArray(d.variables)) d.variables.forEach(v => { if (!v) return; push(v.dependent); push(v.independent); push(v.note); });
          // Outputs + Comments
          push(d.main_outputs);
          if (d.commenti) { push(d.commenti.difetti); push(d.commenti.pregi); push(d.commenti.spunti); push(d.commenti.idee_future); }
          return parts.join(' ').toLowerCase();
        }

        /* ===== caricamento e facets ===== */
        async function loadAll() {
          const tid = (window.Toast && Toast.loading) ? Toast.loading('Caricamento dati...') : null;
          try {
            db = await DataService.getAll();
            if (tid && Toast.update) { Toast.update(tid, 'Dati caricati', 'success'); setTimeout(()=>Toast.dismiss(tid), 800); }
          } catch (e) {
            console.warn('[index] Impossibile caricare dal GAS:', e);
            if (window.Toast && Toast.error) Toast.error('Errore nel caricamento dati');
            db = {};
          }
          computeFacets();
          renderFilters();
          renderNotes();      // ora renderizza libreria
        }

        function computeFacets() {
          const types = new Set();
          const tags = new Set();
          const methods = new Set();
          const animals = new Set();
          for (const doi of Object.keys(db)) {
            const entry = db[doi] || {};
            const notes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
            for (const n of notes) {
              if (n && n.type) types.add(n.type);
              const ts = Array.isArray(n?.tags) ? n.tags : (n?.tags ? [String(n.tags)] : []);
              for (const t of ts) tags.add(t);
              const an = Array.isArray(n?.animals) ? n.animals : (n?.animals ? [String(n.animals)] : []);
              for (const a of an) animals.add(a);
            }
            const mm = entry?.dettagli?.methods;
            (Array.isArray(mm) ? mm : (mm ? [String(mm)] : [])).forEach(m => methods.add(String(m)));
          }
          facets = {
            types: Array.from(types).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'})),
            tags: Array.from(tags).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'})),
            animals: Array.from(animals).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'})),
            methods: Array.from(methods).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'}))
          };
        }

        /* ===== filtri (immutati) ===== */
        function renderFilters() {
          // Title input
          filterTitleEl.value = filters.title;
          filterTitleEl.oninput = () => { filters.title = (filterTitleEl.value || '').toLowerCase().trim(); renderNotes(); };

          // Populate advanced dropdown selects
          function populateMulti(sel, values, selectedSet){
            sel.innerHTML = '';
            for (const v of values){ const op=document.createElement('option'); op.value=v; op.textContent=v; op.selected = selectedSet.has(v); sel.appendChild(op); }
          }
          populateMulti(typeMulti, facets.types, filters.types);
          populateMulti(tagsMulti, facets.tags, filters.tags);
          populateMulti(animalsMulti, facets.animals, filters.animals);
          populateMulti(methodsMulti, facets.methods, filters.methods);

          applyAdv.onclick = () => {
            filters.types = new Set(Array.from(typeMulti.selectedOptions).map(o=>o.value));
            filters.tags = new Set(Array.from(tagsMulti.selectedOptions).map(o=>o.value));
            filters.methods = new Set(Array.from(methodsMulti.selectedOptions).map(o=>o.value));
            filters.animals = new Set(Array.from(animalsMulti.selectedOptions).map(o=>o.value));
            renderNotes();
            renderFilters();
          };
          clearAdv.onclick = () => {
            filters.types = new Set(); filters.tags = new Set(); filters.animals = new Set(); filters.methods = new Set();
            renderFilters(); renderNotes();
          };

          // Dropdown open/close
          function updateAdvBtnLabel(){
            const cnt = filters.types.size + filters.tags.size + filters.animals.size + filters.methods.size;
            advBtn.textContent = cnt ? `Seleziona… (${cnt})` : 'Seleziona…';
          }
          updateAdvBtnLabel();
          advBtn.onclick = (e) => { e.stopPropagation(); advDropdown.classList.toggle('open'); };
          document.addEventListener('click', (e) => { if (!advDropdown.contains(e.target)) advDropdown.classList.remove('open'); });

          // Collapsible filters handling
          const collapsed = loadFiltersCollapsed();
          filtersEl.classList.toggle('collapsed', collapsed);
          if (filtersCollapseBtn) {
            filtersCollapseBtn.setAttribute('aria-expanded', String(!collapsed));
            filtersCollapseBtn.textContent = collapsed ? '▸' : '▾';
            filtersCollapseBtn.onclick = () => {
              const nowCollapsed = !filtersEl.classList.contains('collapsed');
              filtersEl.classList.toggle('collapsed', nowCollapsed);
              filtersCollapseBtn.setAttribute('aria-expanded', String(!nowCollapsed));
              filtersCollapseBtn.textContent = nowCollapsed ? '▸' : '▾';
              saveFiltersCollapsed(nowCollapsed);
            };
          }

          // Render selected filters as removable chips
          function renderSelectedChips(){
            filtersChips.innerHTML = '';
            const addChip = (label, val, removeFn) => {
              const c = document.createElement('span'); c.className = 'chip rem'; c.title = 'Rimuovi';
              c.textContent = `${label}: ${val} ×`;
              c.onclick = () => { removeFn(); renderFilters(); renderNotes(); };
              filtersChips.appendChild(c);
            };
            Array.from(filters.types).forEach(v => addChip('type', v, () => filters.types.delete(v)) );
            Array.from(filters.tags).forEach(v => addChip('tag', v, () => filters.tags.delete(v)) );
            Array.from(filters.animals).forEach(v => addChip('animal', v, () => filters.animals.delete(v)) );
            Array.from(filters.methods).forEach(v => addChip('method', v, () => filters.methods.delete(v)) );
            if (!filters.types.size && !filters.tags.size && !filters.animals.size && !filters.methods.size) {
              const m = document.createElement('div'); m.className='small'; m.textContent='Nessun filtro avanzato selezionato.'; filtersChips.appendChild(m);
            }
            updateAdvBtnLabel();
          }
          renderSelectedChips();
        }

        /* ===== nuova rappresentazione: libreria ===== */
        function renderNotes() {
          notesContainer.innerHTML = '';

          const dois = Object.keys(db);
          if (!dois.length) {
            const empty = document.createElement('div');
            empty.textContent = 'Nessuna nota salvata ancora.';
            empty.style.color = '#6b7280';
            empty.style.fontSize = '14px';
            notesContainer.appendChild(empty);
            return;
          }

          // Precalcola mappa colori per tutti i type presenti (riusato)
          try {
            const types = new Set();
            for (const doi of dois) {
              const entry = db[doi] || {};
              const notes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
              for (const n of notes) { if (n && n.type) types.add(n.type); }
            }
            const map = loadTypeColors();
            let changed = false;
            for (const t of types) {
              if (!map[t]) { map[t] = randomPastel(); changed = true; }
            }
            if (changed) saveTypeColors(map);
          } catch (_) {}

          // Ordina per titolo
          const sections = dois.map(doi => {
            const entry = db[doi] || {};
            const title = getTitle(entry) || doi;
            return { doi, entry, title };
          }).sort((a, b) => a.title.localeCompare(b.title, undefined, { sensitivity: 'base' }));

          // Contenitore libreria con più ripiani (righe auto)
          const bookcase = document.createElement('div');
          bookcase.className = 'bookcase';

          // Parametro: libri per ripiano (responsive semplice)
          const perShelf = window.innerWidth < 700 ? 10 : 16;
          let shelfEl = null, countInRow = 0;

          const query = (filters.title || '').toLowerCase();

          for (const { doi, entry, title } of sections) {
            const textOk = !query || title.toLowerCase().includes(query) || detailsText(entry).includes(query);
            if (!textOk) continue;

            const allNotes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
            // sort by date desc
            allNotes.sort((a, b) => {
              const ta = a && a.createdAt ? new Date(a.createdAt).getTime() : 0;
              const tb = b && b.createdAt ? new Date(b.createdAt).getTime() : 0;
              return tb - ta;
            });

            // filtra per i filtri attivi
            const visible = allNotes.filter(n => matchesFilters(entry, n));
            const count = visible.length;

            // Se filtri avanzati attivi e count==0, nascondi come prima
            const advancedActive = (filters.types.size || filters.tags.size || filters.animals.size || filters.methods.size);
            if (advancedActive && count === 0) continue;

            // colore dorso: dal primo type visibile, fallback pastel
            const firstType = (visible[0] && visible[0].type) || (allNotes[0] && allNotes[0].type) || null;
            const cover = getTypeColor(firstType);

            if (!shelfEl || countInRow >= perShelf) {
              shelfEl = document.createElement('div');
              shelfEl.className = 'shelf';
              bookcase.appendChild(shelfEl);
              countInRow = 0;
            }

            const book = document.createElement('button');
            book.type = 'button';
            book.className = 'book';
            book.style.setProperty('--cover', cover);
            // altezza/spessore in base al numero note (subtle scaling)
            const h = 120 + Math.min(60, count * 4);
            const w = 22 + Math.min(12, Math.ceil(count / 2));
            book.style.setProperty('--h', h + 'px');
            book.style.setProperty('--w', w + 'px');
            book.setAttribute('aria-label', `Apri dettagli: ${title} (${count} note)`);
            book.title = title;

            const spine = document.createElement('div');
            spine.className = 'spine';
            const t = document.createElement('div');
            t.className = 'title';
            t.textContent = title;
            spine.appendChild(t);
            book.appendChild(spine);

            // tooltip custom (per titoli lunghi)
            const tip = document.createElement('div');
            tip.className = 'book-tooltip';
            tip.textContent = title;
            book.appendChild(tip);

            // stick note con count
            const note = document.createElement('div');
            note.className = 'stick-note';
            note.textContent = String(count);
            book.appendChild(note);

            // click -> dettagli
            book.addEventListener('click', () => openDetailsFor(doi));

            // dopo inserimento, adatta font
            requestAnimationFrame(() => adjustSpineFont(t, title, h));

            shelfEl.appendChild(book);
            countInRow++;
          }

          // Se nessun risultato dopo i filtri
          if (!bookcase.children.length) {
            const empty = document.createElement('div');
            empty.textContent = 'Nessun articolo corrisponde ai filtri.';
            empty.style.color = '#6b7280';
            empty.style.fontSize = '14px';
            notesContainer.appendChild(empty);
            return;
          }

          notesContainer.appendChild(bookcase);
        }

        function matchesFilters(entry, note) {
          // title filter
          if (filters.title) {
            const title = (getTitle(entry) || '').toLowerCase();
            if (!title.includes(filters.title)) return false;
          }
          // type filter
          if (filters.types.size) {
            if (!note.type || !filters.types.has(note.type)) return false;
          }
          // tags filter
          if (filters.tags.size) {
            const tags = Array.isArray(note.tags) ? note.tags : (note.tags ? [String(note.tags)] : []);
            const hit = tags.some(t => filters.tags.has(t));
            if (!hit) return false;
          }
          // animals filter
          if (filters.animals.size) {
            const animals = Array.isArray(note.animals) ? note.animals : (note.animals ? [String(note.animals)] : []);
            const hit = animals.some(a => filters.animals.has(a));
            if (!hit) return false;
          }
          // methods filter at article-level
          if (filters.methods.size) {
            const mm = entry?.dettagli?.methods;
            const methods = Array.isArray(mm) ? mm : (mm ? [String(mm)] : []);
            const hit = methods.some(m => filters.methods.has(m));
            if (!hit) return false;
          }
          return true;
        }

        // Manteniamo navigazione originale ai dettagli
        async function openDetailsFor(doi) {
          if (!doi) return;
          window.location.href = `details.html?doi=${encodeURIComponent(doi)}`;
        }

        // Conservata per compat: usata altrove
        async function editNote(doi, noteId) {
          window.location.href = `notes.html?doi=${encodeURIComponent(doi)}&id=${encodeURIComponent(noteId)}`;
        }

        /* ===== helper: sizing titolo sul dorso ===== */
        function adjustSpineFont(el, text, heightPx){
          // Stima: più lungo il testo, più piccolo il font.
          // Bilanciamento empirico: target 12-38 “caratteri-equivalenti” lungo l’asse verticale.
          const len = Math.max(1, (text || '').length);
          const target = Math.max(20, Math.min(40, Math.floor(heightPx / 3))); // “cap” verticali
          // base 9..14 px
          let size = Math.max(9, Math.min(14, Math.floor((target / len) * 120)));
          // clamp extra per dorsi bassi
          if (heightPx < 120) size = Math.max(8, Math.min(size, 12));
          el.style.fontSize = size + 'px';
        }

        // Avvio
        loadAll();

        // Reflow font al resize
        window.addEventListener('resize', () => {
          const titles = document.querySelectorAll('.spine .title');
          titles.forEach(t => {
            const book = t.closest('.book');
            const h = parseInt(getComputedStyle(book).getPropertyValue('--h')) || 140;
            adjustSpineFont(t, t.textContent || '', h);
          });
        });
      })();
    </script>
  </body>
</html>
