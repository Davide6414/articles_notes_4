<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Article Notes</title>
    <link rel="stylesheet" href="project/assets/css/style.css" />
    <script src="project/assets/js/dataService.js"></script>
    <script src="project/assets/js/toast.js"></script>
    <style>
      :root {
        --radius: 12px;
        --gap: 12px;
        --brand: #10b981;     /* verde acqua */
        --brand-2: #06b6d4;   /* azzurro */
        --brand-3: #a7f3d0;   /* verde chiaro */
        --bg: #f8fafc;
        --surface: #ffffff;
        --border-color: #e2e8f0;
        --text: #0f172a;
        --muted: #64748b;
        --chip-bg: #ecfeff;
        --chip-border: #cffafe;
      }

      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        line-height: 1.45;
        margin: 2rem;
        color: var(--text);
        background: var(--bg);
      }

      button, .btn {
        font-size: 14px;
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--surface);
        cursor: pointer;
        transition: background 0.15s ease, transform 0.05s ease;
      }
      button:hover, .btn:hover { background: #f1f5f9; }
      button:active, .btn:active { transform: translateY(1px); }
      .btn.primary { background: var(--brand); color: #fff; border-color: var(--brand); }
      .btn.primary:hover { filter: brightness(0.98); }

      .header {
        margin-bottom: 1rem;
      }

      /* Notes grid + cards */
      .notes-section { margin-top: 20px; }
      .section-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 10px 12px; border: 1px solid var(--border-color); border-radius: 14px; background: linear-gradient(180deg, #f0fdf4, #ecfeff); }
      .section-title { margin: 0; font-size: 18px; }
      .section-title.clickable { cursor: pointer; }
      .section-title.clickable:hover { text-decoration: underline; }
      /* Collapsed as desktop-like tile */
      .notes-section.collapsed { display: inline-block; vertical-align: top; width: 180px; margin-right: 12px; }
      .section-header.collapsed-tile { position: relative; display: grid; justify-items: center; gap: 8px; padding: 14px; background: linear-gradient(180deg, #ecfeff, #dcfce7); }
      .section-header.collapsed-tile .collapse-btn { position: absolute; top: 6px; right: 6px; }
      .article-icon { width: 72px; height: 72px; border-radius: 16px; background: #d1fae5; border: 1px solid #bbf7d0; display: grid; place-items: center; font-size: 36px; }
      .article-caption { text-align: center; font-size: 13px; line-height: 1.2; max-width: 160px; }
      .collapse-btn { font-size: 12px; padding: 6px 10px; border-radius: 10px; border: 1px solid var(--border-color); background: var(--surface); cursor: pointer; }
      .collapse-btn:hover { background: #f1f5f9; }
      .notes-grid {
        display: grid;
        /* Colonne di larghezza fissa; non allargare le card */
        grid-template-columns: repeat(auto-fill, minmax(320px, 320px));
        gap: 16px;
        margin-top: 12px;
        justify-content: start; /* allinea le colonne a sinistra, lascia spazio vuoto a destra */
      }

      .note-card {
        --accent: var(--brand-2);
        border: 1px solid var(--border-color);
        border-left: 6px solid var(--accent);
        border-radius: 14px;
        padding: 12px;
        background: var(--surface);
        display: grid;
        gap: 8px;
        box-shadow: 0 2px 8px rgba(2, 132, 199, 0.06);
      }

      .note-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 8px; }
      .note-title { margin: 0; font-size: 16px; }
      .note-sub { color: var(--muted); font-size: 12px; }

      .type-pill {
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 9999px;
        background: var(--brand-3);
        color: #065f46;
        border: 1px solid rgba(0,0,0,0.06);
        white-space: nowrap;
      }

      .chips { display: flex; flex-wrap: wrap; gap: 6px; }
      .chip { font-size: 12px; padding: 4px 10px; border-radius: 9999px; border: 1px solid var(--border-color); background: #f8fafc; }
      .chip.tag { background: var(--chip-bg); border-color: var(--chip-border); }
      .chip.animal { background: #fefce8; border-color: #fde68a; }

      .image-wrap { border-radius: 10px; overflow: hidden; border: 1px solid #e5e7eb; }
      .image-preview { width: 100%; max-height: 220px; object-fit: cover; display: block; }

      .card-actions { display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-top: 4px; }
      .action-left, .action-right { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

      .btn-link { background: #e0f2fe; border-color: #bae6fd; }

      /* Header actions layout */
      .header-actions { display: flex; gap: 8px; margin-left: auto; align-items: center; flex-wrap: wrap; }
      .header-actions .btn { padding: 6px 10px; font-size: 12px; }
      .section-header.collapsed-tile .header-actions { display: none; }

      /* Filters */
      .filters { margin-top: 16px; padding: 12px; border: 1px solid #e5e7eb; border-radius: 12px; background: #fafafa; }
      .filters h2 { margin: 0; font-size: 16px; }
      .filters-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
      .filters-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
      .filters .row { display: grid; gap: 8px; }
      .filters label { font-size: 12px; color: #374151; }
      .filters input[type="search"] { padding: 8px 10px; border: 1px solid #d0d0d0; border-radius: 8px; font-size: 14px; }
      .filters-actions { display: flex; justify-content: flex-end; }
      .filters.collapsed .filters-grid { display: none; }
      .dropdown { position: relative; display: inline-block; }
      .dropdown-menu { position: absolute; z-index: 40; right: 0; margin-top: 6px; min-width: 520px; max-width: 900px; padding: 12px; border: 1px solid #e5e7eb; border-radius: 12px; background: #fff; box-shadow: 0 10px 30px rgba(0,0,0,0.12); display: none; max-height: 70vh; overflow: auto; resize: both; }
      .dropdown.open .dropdown-menu { display: block; }
      .dropdown-menu.expanded { position: fixed; inset: auto; top: 10vh; left: 50%; transform: translateX(-50%); right: auto; margin-top: 0; width: min(960px, 96vw); max-height: 74vh; }
      .dropdown-menu .controls-line { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; margin: 4px 0; }
      .dropdown-menu .controls-line .btn { padding: 4px 8px; font-size: 12px; }
      .dropdown-menu .search-input { width: 100%; padding: 6px 8px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 13px; }
      .dropdown-menu optgroup[hidden] { display: none; }
      .dropdown .row { margin-bottom: 6px; }
      .dropdown select[multiple] { min-height: 100px; }
      .filters-chips { display: flex; flex-wrap: wrap; gap: 6px; }
      .chip.rem { cursor: pointer; }

      /* Mobile tweaks */
      @media (max-width: 640px) {
        body { margin: 1rem; }
        .notes-section.collapsed { width: 140px; }
        .notes-grid { grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); }
        .section-header { padding: 10px; }
        .note-card { padding: 10px; }
      }

      /* Details shown only in popup via details-popup.html */
    </style>
    <style>
      /* Overlay for references and citations */
      .overlay-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 100; }
      .overlay-backdrop.open { display: flex; }
      .overlay-dialog { max-width: 720px; width: calc(100% - 2rem); background: #fff; border: 1px solid #e5e7eb; border-radius: 12px; box-shadow: 0 20px 50px rgba(0,0,0,0.15); }
      .overlay-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 10px 12px; border-bottom: 1px solid #e5e7eb; }
      .overlay-body { padding: 12px; display: grid; gap: 8px; max-height: 60vh; overflow: auto; }
      .overlay-title { font-size: 16px; margin: 0; }
      .overlay-close { font-size: 14px; padding: 6px 10px; border-radius: 8px; border: 1px solid #e5e7eb; background: #fff; cursor: pointer; }
      .ref-row { display: grid; gap: 2px; padding: 8px; border: 1px solid #e5e7eb; border-radius: 8px; }

      /* Loading overlay */
      .loading-backdrop { position: fixed; inset:0; background: rgba(0,0,0,0.25); display: none; align-items: center; justify-content: center; z-index: 200; }
      .loading-backdrop.open { display: flex; }
      .loading-box { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:16px 20px; min-width:260px; display:grid; gap:10px; align-items:center; justify-items:center; box-shadow: 0 20px 50px rgba(0,0,0,0.15); }
      .spinner { width:28px; height:28px; border:3px solid #e5e7eb; border-top:3px solid var(--brand); border-radius:50%; animation: spin 0.8s linear infinite; }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
  </head>
  <body>
    <h1 class="header">Article Notes</h1>
    <div class="header" style="margin-top:-0.5rem;">
      <div></div>
      <div>
        <a class="btn" href="add-doi.html">Aggiungi DOI</a>
        <a class="btn" href="variabili.html">Variabili</a>
        <a class="btn" href="variabili-tabella.html">Tabella variabili</a>
        <a class="btn" href="grafici.html">Tabella grafici</a>
        <a class="btn" href="glossario.html">Glossario</a>
      </div>
    </div>

    <section class="filters" aria-label="Filtri">
      <div class="filters-header">
        <h2>Filtri</h2>
        <button id="filtersCollapseBtn" class="collapse-btn" aria-expanded="true" title="Comprimi/Espandi">v</button>
      </div>
      <div class="filters-grid">
        <div class="row">
          <label for="filterTitle">Titolo articolo</label>
          <input id="filterTitle" type="search" placeholder="Cerca per titolo..." />
        </div>
        <div class="row">
          <label>Filtri selezionati</label>
          <div id="filtersChips" class="filters-chips"></div>
        </div>
        <div class="row">
          <label>Filtri avanzati</label>
          <div class="dropdown" id="advDropdown">
            <button id="advBtn" class="btn" type="button">Seleziona...</button>
            <div id="advMenu" class="dropdown-menu">
              <div class="row">
                <label for="typeMulti">Types</label>
                <select id="typeMulti" multiple></select>
                <div>
                  <label for="typeLogic" style="font-size:12px;color:#374151;margin-right:6px;">Logica</label>
                  <select id="typeLogic">
                    <option value="OR">Qualsiasi (OR)</option>
                    <option value="AND">Tutti (AND)</option>
                  </select>
                </div>
              </div>
              <div class="row">
                <label for="tagsMulti">Tags</label>
                <select id="tagsMulti" multiple></select>
                <div>
                  <label for="tagsLogic" style="font-size:12px;color:#374151;margin-right:6px;">Logica</label>
                  <select id="tagsLogic">
                    <option value="OR">Qualsiasi (OR)</option>
                    <option value="AND">Tutti (AND)</option>
                  </select>
                </div>
              </div>
              <div class="row">
                <label for="animalsMulti">Animals</label>
                <select id="animalsMulti" multiple></select>
                <div>
                  <label for="animalsLogic" style="font-size:12px;color:#374151;margin-right:6px;">Logica</label>
                  <select id="animalsLogic">
                    <option value="OR">Qualsiasi (OR)</option>
                    <option value="AND">Tutti (AND)</option>
                  </select>
                </div>
              </div>
              <div class="row">
                <label for="methodsMulti">Methods</label>
                <select id="methodsMulti" multiple></select>
                <div>
                  <label for="methodsLogic" style="font-size:12px;color:#374151;margin-right:6px;">Logica</label>
                  <select id="methodsLogic">
                    <option value="OR">Qualsiasi (OR)</option>
                    <option value="AND">Tutti (AND)</option>
                  </select>
                </div>
              </div>
              <div class="filters-actions">
                <button id="applyAdv" class="btn primary" type="button">Applica</button>
                <button id="clearAdv" class="btn" type="button">Pulisci</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="notesSection" aria-label="Note salvate" style="margin-top:16px;">
      <div id="notesContainer"></div>
    </section>

    <!-- Popup disabilitato: gestione via pagine dedicate -->

    <script>
      (function () {
        const notesContainer = document.getElementById('notesContainer');
        const filterTitleEl = document.getElementById('filterTitle');
        const filtersChips = document.getElementById('filtersChips');
        const filtersEl = document.querySelector('section.filters');
        const filtersCollapseBtn = document.getElementById('filtersCollapseBtn');
        // Inject toggles in filters header (view + ordering)
        const filtersHeader = document.querySelector('.filters .filters-header');
        let groupToggleBtn = null;
        let orderToggleBtn = null;
        const advDropdown = document.getElementById('advDropdown');
        const advBtn = document.getElementById('advBtn');
        const advMenu = document.getElementById('advMenu');
        const typeMulti = document.getElementById('typeMulti');
        const tagsMulti = document.getElementById('tagsMulti');
        const animalsMulti = document.getElementById('animalsMulti');
        const methodsMulti = document.getElementById('methodsMulti');
        const typeLogic = document.getElementById('typeLogic');
        const tagsLogic = document.getElementById('tagsLogic');
        const animalsLogic = document.getElementById('animalsLogic');
        const methodsLogic = document.getElementById('methodsLogic');
        const applyAdv = document.getElementById('applyAdv');
        const clearAdv = document.getElementById('clearAdv');

        let db = {};
        let doiIndex = new Map();
        let crossrefCache = new Map();
        const TYPE_COLOR_KEY = 'typeColors.v1';
        const COLLAPSE_KEY = 'notesCollapsed.v1';
        const FILTERS_COLLAPSE_KEY = 'filtersCollapsed.v1';
        const FOLDERS_COLLAPSE_KEY = 'foldersCollapsed.v1';
        const ORDER_KEY = 'orderByColor.v1';
        let facets = { types: [], tags: [], animals: [], methods: [] };
        const GROUP_BY_KEY = 'groupByFolder.v1';
        const LAST_FOLDER_KEY = 'lastFolderUsed.v1';
        function loadGroupByFolder(){ try { return localStorage.getItem(GROUP_BY_KEY) === '1'; } catch(_) { return false; } }
        function saveGroupByFolder(v){ try { localStorage.setItem(GROUP_BY_KEY, v ? '1':'0'); } catch(_){} }
        function getLastFolder(){ try { return localStorage.getItem(LAST_FOLDER_KEY) || ''; } catch(_) { return ''; } }
        function setLastFolder(v){ try { if (v) localStorage.setItem(LAST_FOLDER_KEY, v); } catch(_){} }
        let groupByFolder = loadGroupByFolder();
        function loadOrderByColor(){ try { return localStorage.getItem(ORDER_KEY) === '1'; } catch(_) { return false; } }
        function saveOrderByColor(v){ try { localStorage.setItem(ORDER_KEY, v ? '1':'0'); } catch(_){} }
        let orderByColor = loadOrderByColor();
        let filters = { title: '', types: new Set(), tags: new Set(), animals: new Set(), methods: new Set(), modes: { types: 'OR', tags: 'OR', animals: 'OR', methods: 'OR' } };

        // Allow toggling items in <select multiple> with simple click (no Ctrl/Cmd needed)
        function enableMultiClickToggle(selectEl) {
          if (!selectEl || selectEl.__multiToggleEnabled) return;
          selectEl.addEventListener('mousedown', (e) => {
            const t = e.target;
            if (t && t.tagName === 'OPTION') {
              e.preventDefault();
              const keep = selectEl.scrollTop; // preserve scroll
              t.selected = !t.selected;
              // Fire change so UI relying on it can react if needed
              const evt = new Event('change', { bubbles: true });
              selectEl.dispatchEvent(evt);
              // Restore scroll on next frame to avoid jump
              setTimeout(() => { try { selectEl.scrollTop = keep; } catch (_) {} }, 0);
            }
          });
          selectEl.__multiToggleEnabled = true;
        }

        function loadTypeColors() {
          try { return JSON.parse(localStorage.getItem(TYPE_COLOR_KEY) || '{}') || {}; } catch (_) { return {}; }
        }
        function saveTypeColors(map) {
          try { localStorage.setItem(TYPE_COLOR_KEY, JSON.stringify(map)); } catch (_) {}
        }
        function randomPastel() {
          const h = Math.floor(Math.random() * 360);
          const s = 70; // percent
          const l = 88; // percent
          return `hsl(${h} ${s}% ${l}%)`;
        }
        function getTypeColor(type) {
          if (!type) return '#d1d5db';
          const map = loadTypeColors();
          if (!map[type]) {
            map[type] = randomPastel();
            saveTypeColors(map);
          }
          return map[type];
        }

        function clampImportanza(v){
          const n = parseInt(v, 10);
          if (isNaN(n)) return 1;
          return Math.max(1, Math.min(10, n));
        }
        function importanceToBg(val){
          const v = clampImportanza(val);
          // Green (low) -> Red (high)
          const hueStart = 120; // green
          const hueEnd = 0;     // red
          const hue = hueStart - (v - 1) * ((hueStart - hueEnd) / 9);
          const sat = 70 + (v - 1) * (20 / 9);   // 70% -> ~90%
          const light = 96 - (v - 1) * (10 / 9); // 96% -> ~86%
          return `hsl(${hue.toFixed(1)} ${sat.toFixed(1)}% ${light.toFixed(1)}%)`;
        }

        function formatNoteText(raw) {
          if (raw == null) return '';
          const normalized = String(raw).replace(/\r\n/g, '\n');
          const trimmed = normalized.trim();
          if (!trimmed) return '';

          const startsWithBullet = /^-\s*/.test(trimmed);
          const hasLineBullets = /\n\s*-\s*/.test(trimmed);
          if (startsWithBullet || hasLineBullets) {
            const parts = trimmed.split(/\s*-\s+/).map(part => part.trim()).filter(Boolean);
            if (parts.length > 1) {
              return parts.map(part => `- ${part}`).join('\n');
            }
          }

          return trimmed;
        }

        function loadCollapsed() {
          try { return JSON.parse(localStorage.getItem(COLLAPSE_KEY) || '{}') || {}; } catch (_) { return {}; }
        }
        function saveCollapsed(map) {
          try { localStorage.setItem(COLLAPSE_KEY, JSON.stringify(map)); } catch (_) {}
        }
        function loadFoldersCollapsed() {
          try { return JSON.parse(localStorage.getItem(FOLDERS_COLLAPSE_KEY) || '{}') || {}; } catch (_) { return {}; }
        }
        function saveFoldersCollapsed(map) {
          try { localStorage.setItem(FOLDERS_COLLAPSE_KEY, JSON.stringify(map)); } catch (_) {}
        }
        function loadFiltersCollapsed() {
          try { return localStorage.getItem(FILTERS_COLLAPSE_KEY) === '1'; } catch (_) { return false; }
        }
        function saveFiltersCollapsed(v) {
          try { localStorage.setItem(FILTERS_COLLAPSE_KEY, v ? '1' : '0'); } catch (_) {}
        }

        // Gestione filtri e rendering
        function getTitle(entry) {
          if (!entry) return '';
          const t = entry.title;
          if (Array.isArray(t) && t.length) return t.join(' — ');
          if (typeof t === 'string') return t;
          return '';
        }

        function detailsText(entry) {
          const d = (entry && entry.dettagli) || {};
          const parts = [];
          const push = (v) => { if (v != null && String(v).trim()) parts.push(String(v)); };
          // General
          push(d.ecosistema);
          push(d.background);
          push(d.main_objective);
          push(d.sub_objective);
          push(d.biological_organization);
          // Temporal
          if (d.temporal_scale) {
            push(d.temporal_scale.start);
            push(d.temporal_scale.end);
            push(d.temporal_scale.resolution);
          }
          // Spatial
          if (d.spatial_scale) {
            push(d.spatial_scale.place);
            push(d.spatial_scale.lat);
            push(d.spatial_scale.long);
            push(d.spatial_scale.description);
          }
          // Methods (array)
          if (Array.isArray(d.methods)) d.methods.forEach(push); else push(d.methods);
          // Variables
          if (Array.isArray(d.variables)) {
            d.variables.forEach(v => { if (!v) return; push(v.dependent); push(v.independent); push(v.note); });
          }
          // Outputs
          push(d.main_outputs);
          // Comments
          if (d.commenti) {
            push(d.commenti.difetti);
            push(d.commenti.pregi);
            push(d.commenti.spunti);
            push(d.commenti.idee_future);
          }
          return parts.join(' ').toLowerCase();
        }

        // Overlay helpers
        function ensureOverlay(){
          let back = document.getElementById('overlayBackdrop');
          if (!back) {
            back = document.createElement('div'); back.id = 'overlayBackdrop'; back.className='overlay-backdrop';
            const dialog = document.createElement('div'); dialog.className='overlay-dialog'; dialog.id='overlayDialog';
            const head = document.createElement('div'); head.className='overlay-head';
            const title = document.createElement('h3'); title.className='overlay-title'; title.id='overlayTitle'; title.textContent='';
            const close = document.createElement('button'); close.className='overlay-close'; close.textContent = 'Chiudi';
            close.addEventListener('click', ()=> back.classList.remove('open'));
            head.appendChild(title); head.appendChild(close);
            const body = document.createElement('div'); body.className='overlay-body'; body.id='overlayBody';
            dialog.appendChild(head); dialog.appendChild(body); back.appendChild(dialog); document.body.appendChild(back);
            back.addEventListener('click', (e)=>{ if (e.target === back) back.classList.remove('open'); });
          }
          return back;
        }
        function openOverlay(titleText, nodes){
          const back = ensureOverlay();
          const t = document.getElementById('overlayTitle'); const b = document.getElementById('overlayBody');
          t.textContent = titleText || '';
          b.innerHTML = '';
          if (Array.isArray(nodes)) nodes.forEach(n => b.appendChild(n)); else if (nodes) b.appendChild(nodes);
          back.classList.add('open');
        }

        // Loading overlay helpers
        function ensureLoadingOverlay(){
          let back = document.getElementById('loadingBackdrop');
          if (!back) {
            back = document.createElement('div'); back.id='loadingBackdrop'; back.className='loading-backdrop';
            const box = document.createElement('div'); box.className='loading-box'; box.id='loadingBox';
            const sp = document.createElement('div'); sp.className='spinner'; box.appendChild(sp);
            const msg = document.createElement('div'); msg.id='loadingLabel'; msg.style.fontSize='14px'; msg.textContent=''; box.appendChild(msg);
            back.appendChild(box); document.body.appendChild(back);
          }
          return back;
        }
        function showLoadingOverlay(message){ const back = ensureLoadingOverlay(); const lab = document.getElementById('loadingLabel'); if (lab) lab.textContent = message || 'Caricamento...'; back.classList.add('open'); }
        function updateLoadingOverlay(message){ const lab = document.getElementById('loadingLabel'); if (lab) lab.textContent = message || ''; }
        function hideLoadingOverlay(){ try { const back = document.getElementById('loadingBackdrop'); if (back) back.classList.remove('open'); } catch(_){} }

        function normalizeDoi(raw){
          if (!raw) return '';
          try {
            let s = String(raw).trim();
            s = s.replace(/^https?:\/\/(dx\.)?doi\.org\//i,'');
            s = s.replace(/^doi:\s*/i,'');
            const full = s.match(/10\.\d{4,9}\/[^\s;]+/i);
            const core = full ? full[0] : ( /^10\.\d{4,9}\/\S+$/i.test(s) ? s : '' );
            return core ? core.toLowerCase() : '';
          } catch(_) { return ''; }
        }
        function parseReferences(str){
          const parts = String(str||'').split(';').map(s => normalizeDoi(s)).filter(Boolean);
          return Array.from(new Set(parts));
        }

        async function fetchCrossrefTitle(doi){
          const key = normalizeDoi(doi);
          if (!key) return null;
          if (crossrefCache.has(key)) return crossrefCache.get(key);
          try {
            const res = await fetch(`https://api.crossref.org/works/${encodeURIComponent(key)}`, { headers: { 'Accept':'application/json' } });
            if (!res.ok) throw new Error('HTTP '+res.status);
            const data = await res.json();
            const msg = data && data.message ? data.message : data;
            const title = Array.isArray(msg && msg.title) ? (msg.title[0] || key) : (msg && msg.title) || key;
            crossrefCache.set(key, title);
            return title;
          } catch (_) {
            crossrefCache.set(key, null);
            return null;
          }
        }

        async function loadAll() {
          const tid = (window.Toast && Toast.loading) ? Toast.loading('Caricamento dati...') : null;
          try {
            db = await DataService.getAll();
            if (tid && Toast.update) { Toast.update(tid, 'Dati caricati', 'success'); setTimeout(()=>Toast.dismiss(tid), 800); }
          } catch (e) {
            console.warn('[index] Impossibile caricare dal GAS:', e);
            if (window.Toast && Toast.error) Toast.error('Errore nel caricamento dati');
            db = {};
          }
          computeFacets();
          renderFilters();
          renderNotes();
        }

        function computeFacets() {
          const types = new Set();
          // Case-insensitive tag counting with display mapping
          const tagsCountNorm = {}; // normalized tag -> count across notes
          const tagDisplay = new Map(); // normalized -> first-seen display value
          const methods = new Set();
          const animals = new Set();
          for (const doi of Object.keys(db)) {
            const entry = db[doi] || {};
            const notes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
            for (const n of notes) {
              if (n && n.type) types.add(n.type);
              const ts = Array.isArray(n?.tags) ? n.tags : (n?.tags ? [String(n.tags)] : []);
              for (const t of ts) {
                const disp = String(t).trim();
                const key = disp.toLowerCase();
                tagsCountNorm[key] = (tagsCountNorm[key]||0) + 1;
                if (!tagDisplay.has(key)) tagDisplay.set(key, disp);
              }
              const an = Array.isArray(n?.animals) ? n.animals : (n?.animals ? [String(n.animals)] : []);
              for (const a of an) animals.add(a);
            }
            const mm = entry?.dettagli?.methods;
            (Array.isArray(mm) ? mm : (mm ? [String(mm)] : [])).forEach(m => methods.add(String(m)));
          }
          // Build display list and counts keyed by display label
          const tags = Array.from(tagDisplay.values()).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'}));
          const tagsCountDisplay = {};
          let tagsMaxCount = 0;
          for (const [k, disp] of tagDisplay.entries()) {
            const c = tagsCountNorm[k] || 0; tagsCountDisplay[disp] = c; if (c > tagsMaxCount) tagsMaxCount = c;
          }
          facets = {
            types: Array.from(types).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'})),
            tags,
            tagsCount: tagsCountDisplay,
            tagsCountNorm: tagsCountNorm,
            tagsMaxCount: tagsMaxCount,
            animals: Array.from(animals).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'})),
            methods: Array.from(methods).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'}))
          };
        }

        function tagKey(s){ return String(s||'').trim().toLowerCase(); }
        function applyTagChipStyle(el, tag){
          try {
            const key = tagKey(tag);
            const count = (facets && facets.tagsCountNorm) ? (facets.tagsCountNorm[key]||0) : 0;
            const max = (facets && facets.tagsMaxCount) ? facets.tagsMaxCount : 0;
            if (!max) return;
            const t = Math.max(0, Math.min(1, count / max));
            const light = 98 - Math.round(t * 40);
            const sat = 85;
            el.style.background = `hsl(0 ${sat}% ${light}%)`;
            el.style.color = (light < 75) ? '#fff' : '#7f1d1d';
          } catch (_) {}
        }
        function getTagCount(tag){
          try {
            const key = tagKey(tag);
            return (facets && facets.tagsCountNorm) ? (facets.tagsCountNorm[key]||0) : 0;
          } catch(_) { return 0; }
        }

        function renderFilters() {
          // Build or update the group toggle button
          if (filtersHeader && !groupToggleBtn) {
            groupToggleBtn = document.createElement('button');
            groupToggleBtn.className = 'btn';
            groupToggleBtn.id = 'groupByBtn';
            groupToggleBtn.style.marginLeft = 'auto';
            groupToggleBtn.addEventListener('click', () => { groupByFolder = !groupByFolder; saveGroupByFolder(groupByFolder); updateGroupToggleLabel(); renderNotes(); });
            filtersHeader.insertBefore(groupToggleBtn, filtersCollapseBtn);
          }
          function updateGroupToggleLabel(){ if (groupToggleBtn) groupToggleBtn.textContent = groupByFolder ? 'Vista: Cartelle' : 'Vista: Articoli'; }
          updateGroupToggleLabel();
          // Build or update the order toggle button
          if (filtersHeader && !orderToggleBtn) {
            orderToggleBtn = document.createElement('button');
            orderToggleBtn.className = 'btn';
            orderToggleBtn.id = 'orderByBtn';
            orderToggleBtn.addEventListener('click', () => { orderByColor = !orderByColor; saveOrderByColor(orderByColor); updateOrderToggleLabel(); renderNotes(); });
            filtersHeader.insertBefore(orderToggleBtn, filtersCollapseBtn);
          }
          function updateOrderToggleLabel(){ if (orderToggleBtn) orderToggleBtn.textContent = orderByColor ? 'Ordine: Colore' : 'Ordine: Titolo'; }
          updateOrderToggleLabel();
          // Title input
          filterTitleEl.value = filters.title;
          filterTitleEl.oninput = () => { filters.title = (filterTitleEl.value || '').toLowerCase().trim(); renderNotes(); };

          // Populate advanced dropdown selects
          function populateMulti(sel, values, selectedSet, groupAlpha, counts, sortByCount){
            sel.innerHTML = '';
            const getMax = () => {
              if (!counts) return 0;
              let m = 0; for (const v of values){ const c = counts[v]||0; if (c>m) m=c; } return m;
            };
            const maxCount = getMax();
            const labelFor = (v) => counts ? `${v} (${counts[v]||0})` : v;
            const styleFor = (op, v) => {
              if (!counts) return;
              const c = counts[v]||0; if (!c || !maxCount) return;
              const t = Math.max(0, Math.min(1, c / maxCount));
              const light = 98 - Math.round(t * 40); // 98 -> 58 (più scuro se frequente)
              const sat = 85;
              op.style.background = `hsl(0 ${sat}% ${light}%)`;
              op.style.color = (light < 75) ? '#fff' : '#7f1d1d';
            };
            if (!groupAlpha) {
              const vals = Array.from(values);
              if (sortByCount && counts) vals.sort((a,b)=> (counts[b]||0)-(counts[a]||0) || a.localeCompare(b, undefined, {sensitivity:'base'}));
              for (const v of vals){ const op=document.createElement('option'); op.value=v; op.textContent=labelFor(v); op.selected = selectedSet.has(v); styleFor(op, v); sel.appendChild(op); }
              return;
            }
            // Group by first letter (A–Z), others under '#'
            const groups = new Map();
            const letterOf = (s) => {
              const c = (String(s||'').trim()[0]||'').toUpperCase();
              return (c && c >= 'A' && c <= 'Z') ? c : '#';
            };
            for (const v of values){ const L = letterOf(v); const arr = groups.get(L) || []; arr.push(v); groups.set(L, arr); }
            const letters = Array.from(groups.keys()).sort((a,b)=>{
              if (a==='#' && b!=='#') return -1; if (a!=='#' && b==='#') return 1; return a.localeCompare(b);
            });
            for (const L of letters){
              const og = document.createElement('optgroup'); og.label = L;
              const arr = (groups.get(L) || []).slice();
              if (sortByCount && counts) arr.sort((a,b)=> (counts[b]||0)-(counts[a]||0) || a.localeCompare(b, undefined, {sensitivity:'base'}));
              arr.forEach(v => { const op=document.createElement('option'); op.value=v; op.textContent=labelFor(v); op.selected = selectedSet.has(v); styleFor(op, v); og.appendChild(op); });
              sel.appendChild(og);
            }
          }
          const tagsSortByCount = (localStorage.getItem('tagsSortByCount.v1') === '1');
          populateMulti(typeMulti, facets.types, filters.types, false, null, false);
          populateMulti(tagsMulti, facets.tags, filters.tags, true, facets.tagsCount || null, tagsSortByCount);
          populateMulti(animalsMulti, facets.animals, filters.animals, false, null, false);
          populateMulti(methodsMulti, facets.methods, filters.methods, false, null, false);

          // Enable simple click toggling for all multi-selects
          enableMultiClickToggle(typeMulti);
          enableMultiClickToggle(tagsMulti);
          enableMultiClickToggle(animalsMulti);
          enableMultiClickToggle(methodsMulti);

          // Enlarge lists for usability
          typeMulti.size = 8; tagsMulti.size = 14; animalsMulti.size = 8; methodsMulti.size = 8;

          // Helpers: search + select all/none/invert
          function addSelectHelpers(sel, keyPrefix, supportSort){
            const row = sel.closest('.row') || sel.parentElement;
            if (!row) return;
            // Search box
            let search = row.querySelector(`input[data-for='${sel.id}']`);
            if (!search) {
              search = document.createElement('input'); search.type='search'; search.placeholder='Filtra...'; search.className='search-input'; search.setAttribute('data-for', sel.id);
              row.insertBefore(search, sel);
            }
            const applyFilter = () => {
              const q = (search.value||'').toLowerCase().trim();
              // show/hide options and hide empty optgroups
              const opts = Array.from(sel.options);
              const visibleMap = new Map();
              opts.forEach(op => {
                const txt = (op.textContent||'').toLowerCase();
                const vis = !q || txt.includes(q);
                op.hidden = !vis;
                const og = op.parentElement && op.parentElement.tagName === 'OPTGROUP' ? op.parentElement : null;
                if (og) visibleMap.set(og, (visibleMap.get(og)||0) + (vis?1:0));
              });
              // toggle optgroups
              Array.from(sel.querySelectorAll('optgroup')).forEach(og => { const v = visibleMap.get(og)||0; og.hidden = (v === 0); });
            };
            search.oninput = applyFilter;

            // Controls line
            let line = row.querySelector(`.controls-line[data-for='${sel.id}']`);
            if (!line) { line = document.createElement('div'); line.className='controls-line'; line.setAttribute('data-for', sel.id); row.appendChild(line); }
            const mkBtn = (txt, fn) => { const b=document.createElement('button'); b.type='button'; b.className='btn'; b.textContent=txt; b.addEventListener('click', fn); return b; };
            line.innerHTML = '';
            line.appendChild(mkBtn('Seleziona tutto', ()=>{ Array.from(sel.options).forEach(o=>{ if(!o.hidden) o.selected=true; }); sel.dispatchEvent(new Event('change',{bubbles:true})); }));
            line.appendChild(mkBtn('Nessuno', ()=>{ Array.from(sel.options).forEach(o=>{ if(!o.hidden) o.selected=false; }); sel.dispatchEvent(new Event('change',{bubbles:true})); }));
            line.appendChild(mkBtn('Inverti', ()=>{ Array.from(sel.options).forEach(o=>{ if(!o.hidden) o.selected=!o.selected; }); sel.dispatchEvent(new Event('change',{bubbles:true})); }));
            if (supportSort) {
              const sortBtn = mkBtn(tagsSortByCount ? 'Ordina A→Z' : 'Ordina per frequenza', ()=>{
                const next = !tagsSortByCount; localStorage.setItem('tagsSortByCount.v1', next ? '1':'0'); renderFilters();
              });
              line.appendChild(sortBtn);
            }
            // First application of filter
            applyFilter();
          }
          addSelectHelpers(typeMulti, 'types', false);
          addSelectHelpers(tagsMulti, 'tags', true);
          addSelectHelpers(animalsMulti, 'animals', false);
          addSelectHelpers(methodsMulti, 'methods', false);

          applyAdv.onclick = () => {
            filters.types = new Set(Array.from(typeMulti.selectedOptions).map(o=>o.value));
            filters.tags = new Set(Array.from(tagsMulti.selectedOptions).map(o=>o.value));
            filters.methods = new Set(Array.from(methodsMulti.selectedOptions).map(o=>o.value));
            filters.animals = new Set(Array.from(animalsMulti.selectedOptions).map(o=>o.value));
            // logic modes
            filters.modes.types = (typeLogic && typeLogic.value) || 'OR';
            filters.modes.tags = (tagsLogic && tagsLogic.value) || 'OR';
            filters.modes.animals = (animalsLogic && animalsLogic.value) || 'OR';
            filters.modes.methods = (methodsLogic && methodsLogic.value) || 'OR';
            // non chiudere forzatamente; lasciare aperto se l'utente vuole continuare
            renderNotes();
            renderFilters();
          };
          clearAdv.onclick = () => {
            filters.types = new Set(); filters.tags = new Set(); filters.animals = new Set(); filters.methods = new Set();
            filters.modes = { types: 'OR', tags: 'OR', animals: 'OR', methods: 'OR' };
            renderFilters(); renderNotes();
          };

          // Initialize logic selects
          if (typeLogic) typeLogic.value = filters.modes.types || 'OR';
          if (tagsLogic) tagsLogic.value = filters.modes.tags || 'OR';
          if (animalsLogic) animalsLogic.value = filters.modes.animals || 'OR';
          if (methodsLogic) methodsLogic.value = filters.modes.methods || 'OR';

          // Dropdown open/close
          function updateAdvBtnLabel(){
            const cnt = filters.types.size + filters.tags.size + filters.animals.size + filters.methods.size;
            advBtn.textContent = cnt ? `Seleziona... (${cnt})` : 'Seleziona...';
          }
          updateAdvBtnLabel();
          // Top controls: expand/close
          function ensureTopControls(){
            let top = advMenu.querySelector('.controls-line.top');
            if (!top) { top = document.createElement('div'); top.className='controls-line top'; advMenu.insertBefore(top, advMenu.firstChild); }
            top.innerHTML='';
            const mkBtn = (txt, fn) => { const b=document.createElement('button'); b.type='button'; b.className='btn'; b.textContent=txt; b.addEventListener('click', fn); return b; };
            const expanded = advMenu.classList.contains('expanded');
            top.appendChild(mkBtn(expanded ? 'Riduci' : 'Espandi', ()=>{ advMenu.classList.toggle('expanded'); }));
            top.appendChild(mkBtn('Chiudi', ()=>{ advDropdown.classList.remove('open'); advMenu.classList.remove('expanded'); }));
          }
          ensureTopControls();

          advBtn.onclick = (e) => { e.stopPropagation(); advDropdown.classList.toggle('open'); ensureTopControls(); };
          document.addEventListener('click', (e) => { if (!advDropdown.contains(e.target)) advDropdown.classList.remove('open'); });
          document.addEventListener('keydown', (e) => { if (e.key === 'Escape') { advDropdown.classList.remove('open'); advMenu.classList.remove('expanded'); } });

          // Collapsible filters handling
          const collapsed = loadFiltersCollapsed();
          filtersEl.classList.toggle('collapsed', collapsed);
          if (filtersCollapseBtn) {
            filtersCollapseBtn.setAttribute('aria-expanded', String(!collapsed));
            filtersCollapseBtn.textContent = collapsed ? '>' : 'v';
            filtersCollapseBtn.onclick = () => {
              const nowCollapsed = !filtersEl.classList.contains('collapsed');
              filtersEl.classList.toggle('collapsed', nowCollapsed);
              filtersCollapseBtn.setAttribute('aria-expanded', String(!nowCollapsed));
              filtersCollapseBtn.textContent = nowCollapsed ? '>' : 'v';
              saveFiltersCollapsed(nowCollapsed);
            };
          }

          // Render selected filters as removable chips
          function renderSelectedChips(){
            filtersChips.innerHTML = '';
            const addChip = (label, val, removeFn) => {
              const c = document.createElement('span'); c.className = 'chip rem'; c.title = 'Rimuovi';
              c.textContent = `${label}: ${val} ×`;
              c.onclick = () => { removeFn(); renderFilters(); renderNotes(); };
              filtersChips.appendChild(c);
            };
            Array.from(filters.types).forEach(v => addChip('type', v, () => filters.types.delete(v)) );
            Array.from(filters.tags).forEach(v => {
              const cnt = (facets && facets.tagsCount && Object.prototype.hasOwnProperty.call(facets.tagsCount, v)) ? facets.tagsCount[v] : 0;
              const lab = cnt ? `${v} (${cnt})` : v;
              const c = document.createElement('span'); c.className = 'chip rem'; c.title = 'Rimuovi';
              c.textContent = `tag: ${lab} x`;
              c.onclick = () => { filters.tags.delete(v); renderFilters(); renderNotes(); };
              filtersChips.appendChild(c);
            });
            Array.from(filters.animals).forEach(v => addChip('animal', v, () => filters.animals.delete(v)) );
            Array.from(filters.methods).forEach(v => addChip('method', v, () => filters.methods.delete(v)) );
            if (!filters.types.size && !filters.tags.size && !filters.animals.size && !filters.methods.size) {
              const m = document.createElement('div'); m.className='small'; m.textContent='Nessun filtro avanzato selezionato.'; filtersChips.appendChild(m);
            }
            updateAdvBtnLabel();
          }
          renderSelectedChips();
        }

        function createCard(doi, entry, note) {
          const card = document.createElement('article');
          card.className = 'note-card';
          const accent = getTypeColor(note.type);
          card.style.setProperty('--accent', accent);
          // Background based on importanza 1..10 (pale yellow -> intense red)
          const impBg = importanceToBg(note && note.importanza != null ? note.importanza : 1);
          card.style.background = impBg;

          const header = document.createElement('div');
          header.className = 'note-header';
          if (note.type) {
            const tp = document.createElement('span');
            tp.className = 'type-pill';
            tp.textContent = note.type;
            header.appendChild(tp);
          }
          card.appendChild(header);

          const sub = document.createElement('div');
          sub.className = 'note-sub';
          sub.textContent = 'DOI: ' + doi + (note.createdAt ? ' • ' + new Date(note.createdAt).toLocaleString() : '');
          card.appendChild(sub);

          // Image preview if present
          if (note.imageUrl) {
            const wrap = document.createElement('div');
            wrap.className = 'image-wrap';
            const a = document.createElement('a');
            a.href = note.imageUrl; a.target = '_blank'; a.rel = 'noopener noreferrer';
            const img = document.createElement('img');
            img.className = 'image-preview';
            img.alt = getTitle(entry) || 'image';
            img.src = note.imageUrl;
            img.addEventListener('error', () => {
              try { wrap.remove(); } catch (_) {}
            });
            a.appendChild(img);
            wrap.appendChild(a);
            card.appendChild(wrap);
          }

          if (note.text) {
            const formatted = formatNoteText(note.text);
            if (formatted) {
              const p = document.createElement('p');
              p.textContent = formatted;
              p.style.margin = '4px 0';
              p.style.whiteSpace = 'pre-wrap';
              p.style.paddingLeft = '12px';
              card.appendChild(p);
            }
          }

          if (note.comment) {
            const c = document.createElement('div');
            c.className = 'note-sub';
            c.textContent = 'Commento: ' + note.comment;
            card.appendChild(c);
          }

          // Chips: tags
          const tags = Array.isArray(note.tags) ? note.tags : (note.tags ? [String(note.tags)] : []);
          if (tags.length) {
            const chips = document.createElement('div');
            chips.className = 'chips';
            for (const t of tags) {
              const c = document.createElement('span');
              c.className = 'chip tag';
              const cnt = getTagCount(t);
              c.textContent = `${t} (${cnt})`;
              applyTagChipStyle(c, t);
              chips.appendChild(c);
            }
            card.appendChild(chips);
          }

          // Chips: animals
          const animals = Array.isArray(note.animals) ? note.animals : (note.animals ? [String(note.animals)] : []);
          if (animals.length) {
            const chips = document.createElement('div');
            chips.className = 'chips';
            for (const a of animals) {
              const c = document.createElement('span');
              c.className = 'chip animal';
              c.textContent = a;
              chips.appendChild(c);
            }
            card.appendChild(chips);
          }

          const actions = document.createElement('div');
          actions.className = 'card-actions';
          const left = document.createElement('div');
          left.className = 'action-left';
          const right = document.createElement('div');
          right.className = 'action-right';

          if (note.url) {
            const linkBtn = document.createElement('button');
            linkBtn.className = 'btn btn-link';
            linkBtn.textContent = 'Link';
            linkBtn.addEventListener('click', () => { try { window.open(note.url, '_blank', 'noopener'); } catch (_) {} });
            left.appendChild(linkBtn);
          }
          if (note.imageUrl) {
            const imgBtn = document.createElement('button');
            imgBtn.className = 'btn btn-link';
            imgBtn.textContent = 'Immagine';
            imgBtn.addEventListener('click', () => { try { window.open(note.imageUrl, '_blank', 'noopener'); } catch (_) {} });
            left.appendChild(imgBtn);
          }

          // References button
          try {
            const refs = parseReferences(note && note.references);
            if (refs && refs.length) {
              const refBtn = document.createElement('button');
              refBtn.className = 'btn';
              refBtn.textContent = 'Mostra references';
              refBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const nodes = [];
                for (const r of refs) {
                  const row = document.createElement('div'); row.className='ref-row';
                  const title = await fetchCrossrefTitle(r);
                  const t = document.createElement('div'); t.textContent = title || r; row.appendChild(t);
                  const d = document.createElement('div'); d.className='muted'; d.textContent = r; row.appendChild(d);
                  const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='8px'; actions.style.marginTop='4px';
                  const a1 = Object.assign(document.createElement('a'), { href:`https://doi.org/${encodeURIComponent(r)}`, target:'_blank', rel:'noopener noreferrer', textContent:'Apri DOI' }); actions.appendChild(a1);
                  const internalKey = doiIndex.get(normalizeDoi(r));
                  if (internalKey) {
                    const a2 = Object.assign(document.createElement('a'), { href:`details.html?doi=${encodeURIComponent(internalKey)}`, textContent:'Apri in sistema' }); actions.appendChild(a2);
                  }
                  row.appendChild(actions);
                  nodes.push(row);
                }
                openOverlay('References', nodes);
              });
              left.appendChild(refBtn);
            }
          } catch (_) {}

          const editBtn = document.createElement('button');
          editBtn.className = 'btn';
          editBtn.textContent = 'Modifica';
          editBtn.addEventListener('click', (e) => { e.stopPropagation(); editNote(doi, note); });
          right.appendChild(editBtn);

          actions.appendChild(left);
          actions.appendChild(right);
          card.appendChild(actions);

          return card;
        }

        function matchesFilters(entry, note) {
          // title filter
          if (filters.title) {
            const title = (getTitle(entry) || '').toLowerCase();
            if (!title.includes(filters.title)) return false;
          }
          // type filter: OR by default; AND means: l'articolo deve contenere tutte le type selezionate
          if (filters.types.size) {
            const mode = (filters.modes && filters.modes.types) || 'OR';
            if (mode === 'OR') {
              if (!note.type || !filters.types.has(note.type)) return false;
            } else {
              // AND: articolo deve avere almeno una nota per ogni type selezionata
              const notes = Array.isArray(entry?.user_notes) ? entry.user_notes : (entry?.user_note ? [entry.user_note] : []);
              const articleTypes = new Set();
              for (const n of notes) { if (n && n.type) articleTypes.add(n.type); }
              for (const t of Array.from(filters.types)) { if (!articleTypes.has(t)) return false; }
              // e la nota corrente deve comunque appartenere a una delle type selezionate
              if (!note.type || !filters.types.has(note.type)) return false;
            }
          }
          // tags filter (OR/AND tra selezioni) - case-insensitive
          if (filters.tags.size) {
            const tagsRaw = Array.isArray(note.tags) ? note.tags : (note.tags ? [String(note.tags)] : []);
            const tags = tagsRaw.map(t => tagKey(t));
            const selected = new Set(Array.from(filters.tags).map(t => tagKey(t)));
            const mode = (filters.modes && filters.modes.tags) || 'OR';
            if (mode === 'OR') {
              const hit = tags.some(t => selected.has(t));
              if (!hit) return false;
            } else {
              for (const t of Array.from(selected)) { if (!tags.includes(t)) return false; }
            }
          }
          // animals filter (OR/AND tra selezioni) per nota
          if (filters.animals.size) {
            const animals = Array.isArray(note.animals) ? note.animals : (note.animals ? [String(note.animals)] : []);
            const mode = (filters.modes && filters.modes.animals) || 'OR';
            if (mode === 'OR') {
              const hit = animals.some(a => filters.animals.has(a));
              if (!hit) return false;
            } else {
              for (const a of Array.from(filters.animals)) { if (!animals.includes(a)) return false; }
            }
          }
          // methods filter (OR/AND tra selezioni) at article-level
          if (filters.methods.size) {
            const mode = (filters.modes && filters.modes.methods) || 'OR';
            const mm = entry?.dettagli?.methods;
            const methods = Array.isArray(mm) ? mm : (mm ? [String(mm)] : []);
            if (mode === 'OR') {
              const hit = methods.some(m => filters.methods.has(m));
              if (!hit) return false;
            } else {
              for (const m of Array.from(filters.methods)) { if (!methods.includes(m)) return false; }
            }
          }
          return true;
        }

        // Details visualization is handled in details-popup.html, opened on title click

        function renderNotes() {
          notesContainer.innerHTML = '';
          const dois = Object.keys(db);
          if (!dois.length) {
            const empty = document.createElement('div');
            empty.textContent = 'Nessuna nota salvata ancora.';
            empty.style.color = '#6b7280';
            empty.style.fontSize = '14px';
            notesContainer.appendChild(empty);
            return;
          }

          // Precalcola mappa colori per tutti i type presenti
          try {
            const types = new Set();
            for (const doi of dois) {
              const entry = db[doi] || {};
              const notes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
              for (const n of notes) { if (n && n.type) types.add(n.type); }
            }
            const map = loadTypeColors();
            let changed = false;
            for (const t of types) {
              if (!map[t]) { map[t] = randomPastel(); changed = true; }
            }
            if (changed) saveTypeColors(map);
          } catch (_) {}

          // Build DOI index and cited-by map
          doiIndex = new Map();
          Object.keys(db).forEach(key => { const norm = normalizeDoi(key); if (norm) doiIndex.set(norm, key); });
          const citedBy = new Map(); // normTarget -> Set(normCiting)
          for (const citeDoi of dois) {
            const entry = db[citeDoi] || {};
            const notes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
            for (const n of notes) {
              const refs = parseReferences(n && n.references);
              for (const r of refs) {
                const set = citedBy.get(r) || new Set();
                const normCiting = normalizeDoi(citeDoi) || citeDoi;
                set.add(normCiting);
                citedBy.set(r, set);
              }
            }
          }

          // Ordina le sezioni per titolo (fallback DOI)
          function folderLabelOf(entry){ const s = String((entry && entry.cartella) || '').trim(); return s || 'Senza cartella'; }
          const items = dois.map(doi => {
            const entry = db[doi] || {};
            const title = getTitle(entry) || doi;
            const folder = folderLabelOf(entry);
            return { doi, entry, title, folder };
          });
          // Build a rainbow-like color map for folders (uniform distribution)
          function makeFolderColorMap(items){
            try {
              const special = 'Senza cartella';
              const namesAll = Array.from(new Set(items.map(x => x.folder)));
              const names = namesAll.filter(n => String(n||'').toLowerCase() !== special.toLowerCase())
                                    .sort((a,b)=> a.localeCompare(b, undefined, {sensitivity:'base'}));
              const map = new Map();
              // Neutral default for special
              map.set(special, { border: '#d1d5db', bg: '#e5e7eb', hue: -1 });
              const n = Math.max(1, names.length);
              names.forEach((name, i) => {
                const hue = Math.round((i * 360) / n);
                const border = `hsl(${hue} 75% 42%)`;
                const bg = `hsl(${hue} 85% 86%)`;
                map.set(name, { border, bg, hue });
              });
              return map;
            } catch (_) { return new Map(); }
          }
          const folderColorMap = makeFolderColorMap(items);
          const sections = items.sort((a, b) => {
            if (!groupByFolder && orderByColor) {
              const ca = (folderColorMap.get(a.folder) || {}).hue;
              const cb = (folderColorMap.get(b.folder) || {}).hue;
              const ha = (typeof ca === 'number') ? ca : 9999;
              const hb = (typeof cb === 'number') ? cb : 9999;
              if (ha !== hb) return ha - hb;
            }
            if (groupByFolder) {
              const af = (a.folder || '').toLowerCase();
              const bf = (b.folder || '').toLowerCase();
              const az = af === 'senza cartella' ? '' : af;
              const bz = bf === 'senza cartella' ? '' : bf;
              const cmpF = az.localeCompare(bz, undefined, { sensitivity: 'base' });
              if (cmpF !== 0) return cmpF;
            }
            return a.title.localeCompare(b.title, undefined, { sensitivity: 'base' });
          });
          const collapsedMap = loadCollapsed();

          // If grouping by folder, render grouped view with persistent folder collapsing and exit early
          if (groupByFolder) {
            const foldersCollapsed = loadFoldersCollapsed();

            function buildArticleSection(doi, entry, title) {
              const query = (filters.title || '').toLowerCase();
              const matchesText = !query || title.toLowerCase().includes(query) || detailsText(entry).includes(query);
              if (!matchesText) return null;
              const notes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
              notes.sort((a, b) => { const ta = a && a.createdAt ? new Date(a.createdAt).getTime() : 0; const tb = b && b.createdAt ? new Date(b.createdAt).getTime() : 0; return tb - ta; });
              const visible = notes.filter(n => matchesFilters(entry, n));
              const count = visible.length;
              const advancedActive = (filters.types.size || filters.tags.size || filters.animals.size || filters.methods.size);
              if (advancedActive && count === 0) return null;

              const section = document.createElement('section'); section.className = 'notes-section';
              const header = document.createElement('div'); header.className = 'section-header';
              const btn = document.createElement('button'); btn.className = 'collapse-btn';
              const collapsed = !!collapsedMap[doi]; btn.setAttribute('aria-expanded', String(!collapsed)); btn.textContent = collapsed ? '>' : 'v'; header.appendChild(btn);
            const icon = document.createElement('div'); icon.className = 'article-icon'; icon.textContent = '??';
              // Color by folder
              try { const fname = folderLabelOf(entry); const fc = folderColorMap.get(fname) || folderColorMap.get('Senza cartella'); if (fc){ icon.style.borderColor = fc.border; icon.style.background = fc.bg; } } catch(_){}
              const caption = document.createElement('div'); caption.className = 'article-caption'; caption.textContent = title;
              function applyHeaderLayout() {
                header.innerHTML = ''; header.appendChild(btn);
                if (section.classList.contains('collapsed')) { header.classList.add('collapsed-tile'); header.appendChild(icon); header.appendChild(caption); }
                else {
                  header.classList.remove('collapsed-tile');
                  const titleEl = document.createElement('h2'); titleEl.className = 'section-title clickable'; titleEl.textContent = `${title} (${count})`;
                  titleEl.setAttribute('tabindex', '0');
                  titleEl.addEventListener('click', () => openDetailsFor(doi));
                  titleEl.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); openDetailsFor(doi); } });
                  header.appendChild(titleEl);
                  if (entry && entry.cartella) { const fchip = document.createElement('span'); fchip.className = 'chip'; fchip.textContent = `Cartella: ${entry.cartella}`; header.appendChild(fchip); }
                }
                const actions = document.createElement('div'); actions.className = 'header-actions';
                const searchDoiBtn = document.createElement('button'); searchDoiBtn.className = 'btn'; searchDoiBtn.textContent = 'Cerca DOI';
                searchDoiBtn.addEventListener('click', (e) => { e.stopPropagation(); const url = `https://www.google.com/search?q=${encodeURIComponent(doi)}`; try { window.open(url, '_blank', 'noopener'); } catch (_) {} });
                const copyDoiBtn = document.createElement('button'); copyDoiBtn.className = 'btn'; copyDoiBtn.textContent = 'Copia DOI';
                copyDoiBtn.addEventListener('click', async (e) => { e.stopPropagation(); const text = String(doi||''); let ok=false; try{ if (navigator.clipboard && navigator.clipboard.writeText){ await navigator.clipboard.writeText(text); ok=true; } } catch(_){} if(!ok){ try{ const ta=document.createElement('textarea'); ta.value=text; ta.style.position='fixed'; ta.style.left='-9999px'; document.body.appendChild(ta); ta.focus(); ta.select(); ok=document.execCommand('copy'); document.body.removeChild(ta);}catch(_){ok=false;} } if (ok){ Toast&&Toast.success&&Toast.success('DOI copiato'); } else { Toast&&Toast.error&&Toast.error('Impossibile copiare il DOI'); } });
                actions.appendChild(searchDoiBtn); actions.appendChild(copyDoiBtn);
                try { const normSelf = normalizeDoi(doi); const set = normSelf ? (citedBy.get(normSelf) || new Set()) : new Set(); const countCited = set.size; if (countCited>0){ const cbBtn=document.createElement('button'); cbBtn.className='btn'; cbBtn.textContent = `Cited by (${countCited})`; cbBtn.addEventListener('click', (e)=>{ e.stopPropagation(); const nodes=[]; const list=Array.from(set); list.forEach(normCiting=>{ const key=doiIndex.get(normCiting)||normCiting; const ent=db[key]; const t=getTitle(ent)||key; const row=document.createElement('div'); row.className='ref-row'; const d1=document.createElement('div'); d1.textContent=t; row.appendChild(d1); const d2=document.createElement('div'); d2.className='muted'; d2.textContent=key; row.appendChild(d2); const a=Object.assign(document.createElement('a'), { href:`details.html?doi=${encodeURIComponent(key)}`, textContent:'Apri' }); row.appendChild(a); nodes.push(row); }); openOverlay('Articoli che citano questo DOI', nodes); }); actions.appendChild(cbBtn); } } catch(_){}
                const addNoteBtn=document.createElement('button'); addNoteBtn.className='btn'; addNoteBtn.textContent='Aggiungi nota'; addNoteBtn.addEventListener('click',(e)=>{ e.stopPropagation(); window.location.href=`notes.html?doi=${encodeURIComponent(doi)}`; });
                const varsBtn=document.createElement('button'); varsBtn.className='btn'; varsBtn.textContent='Variabili'; varsBtn.addEventListener('click',(e)=>{ e.stopPropagation(); window.location.href=`variabili.html?doi=${encodeURIComponent(doi)}`; });
                const assignFolderBtn=document.createElement('button'); assignFolderBtn.className='btn'; assignFolderBtn.textContent='Assegna cartella';
                assignFolderBtn.addEventListener('click', async (e)=>{
                  e.stopPropagation();
                  try {
                    const full = await DataService.getAll();
                    const base = full[doi] || { DOI: doi };
                    const def = (base && base.cartella) || getLastFolder();
                    const fset = new Set(); try { Object.keys(full||{}).forEach(k => { const v = String((full[k] && full[k].cartella) || '').trim(); if (v) fset.add(v); }); } catch(_){}
                    const folders = Array.from(fset).sort((a,b)=> a.localeCompare(b, undefined, {sensitivity:'base'}));
                    const nodes=[]; const row=document.createElement('div'); row.className='row'; const lab=document.createElement('label'); lab.textContent='Cartella'; row.appendChild(lab);
                    const inp=Object.assign(document.createElement('input'), { type:'text', id:'folderAssignInput', value: def||'', placeholder:'es. Capitolo 1 / Energia' }); inp.setAttribute('list','folderDatalist'); row.appendChild(inp);
                    const dl=document.createElement('datalist'); dl.id='folderDatalist'; folders.forEach(f=>{ const op=document.createElement('option'); op.value=f; dl.appendChild(op); }); nodes.push(row); nodes.push(dl);
                    if (folders.length){ const chips=document.createElement('div'); chips.className='chips'; folders.forEach(f=>{ const c=document.createElement('span'); c.className='chip'; c.textContent=f; c.style.cursor='pointer'; c.addEventListener('click', ()=>{ inp.value=f; }); chips.appendChild(c); }); nodes.push(chips);} 
                    const actions=document.createElement('div'); actions.style.display='flex'; actions.style.gap='8px'; const saveB=Object.assign(document.createElement('button'), { className:'btn primary', type:'button', textContent:'Salva' }); const clearB=Object.assign(document.createElement('button'), { className:'btn', type:'button', textContent:'Rimuovi' }); const cancelB=Object.assign(document.createElement('button'), { className:'btn', type:'button', textContent:'Annulla' }); actions.appendChild(saveB); actions.appendChild(clearB); actions.appendChild(cancelB); nodes.push(actions); openOverlay('Assegna cartella', nodes);
                    const closeOverlay = ()=>{ try{ const back=document.getElementById('overlayBackdrop'); if (back) back.classList.remove('open'); } catch(_){} };
                    clearB.addEventListener('click', ()=> { inp.value=''; inp.focus(); }); cancelB.addEventListener('click', closeOverlay); inp.addEventListener('keydown', (ev)=>{ if (ev.key==='Enter') saveB.click(); });
                    saveB.addEventListener('click', async ()=>{ const folder=String(inp.value||'').trim(); const combined=Object.assign({}, base); if (folder){ combined.cartella=folder; setLastFolder(folder); } else { delete combined.cartella; } showLoadingOverlay('Salvataggio cartella...'); try { await DataService.saveRecord(doi, combined); db[doi] = combined; renderNotes(); closeOverlay(); updateLoadingOverlay('Cartella salvata e lista aggiornata'); setTimeout(()=> hideLoadingOverlay(), 700); } catch(err){ console.error('Assegna cartella fallito', err); hideLoadingOverlay(); Toast&&Toast.error&&Toast.error('Errore salvataggio cartella'); alert('Errore durante il salvataggio'); } });
                  } catch (e) { console.error('Assegna cartella init fallito', e); Toast&&Toast.error&&Toast.error('Errore apertura dialog cartella'); }
                });
                actions.appendChild(addNoteBtn); actions.appendChild(assignFolderBtn); actions.appendChild(varsBtn);
                if (!section.classList.contains('collapsed')) header.appendChild(actions);
              }
              if (collapsed) section.classList.add('collapsed');
              applyHeaderLayout(); section.appendChild(header);
              const grid = document.createElement('div'); grid.className = 'notes-grid'; if (collapsed) grid.style.display = 'none';
              if (count > 0) { for (const note of visible) { const card = createCard(doi, entry, note); grid.appendChild(card); } }
              else if (!collapsed) { const placeholder=document.createElement('div'); placeholder.textContent='Nessuna nota per questo articolo.'; placeholder.style.color='#6b7280'; placeholder.style.fontSize='14px'; placeholder.style.gridColumn='1 / -1'; grid.appendChild(placeholder); }
              btn.addEventListener('click', (e)=>{ e.stopPropagation(); const nowCollapsed = grid.style.display !== 'none' ? true : false; grid.style.display = nowCollapsed ? 'none' : ''; section.classList.toggle('collapsed', nowCollapsed); btn.textContent = nowCollapsed ? '>' : 'v'; btn.setAttribute('aria-expanded', String(!nowCollapsed)); collapsedMap[doi] = nowCollapsed; saveCollapsed(collapsedMap); applyHeaderLayout(); });
              section.appendChild(grid);
              return section;
            }

            // Build groups only with visible articles
            const groups = new Map();
            sections.forEach(it => {
              const el = buildArticleSection(it.doi, it.entry, it.title);
              if (!el) return; const arr = groups.get(it.folder) || []; arr.push({ node: el, sortKey: it.title }); groups.set(it.folder, arr);
            });
            const names = Array.from(groups.keys()).sort((a,b)=>{
              if (orderByColor) {
                const ca = (folderColorMap.get(a) || {}).hue; const cb = (folderColorMap.get(b) || {}).hue;
                const ha = (typeof ca === 'number') ? ca : 9999; const hb = (typeof cb === 'number') ? cb : 9999;
                if (ha !== hb) return ha - hb;
              }
              const az=(String(a).toLowerCase()==='senza cartella')?'':String(a);
              const bz=(String(b).toLowerCase()==='senza cartella')?'':String(b);
              return az.localeCompare(bz, undefined, {sensitivity:'base'});
            });
            if (names.length === 0) {
              const empty = document.createElement('div'); empty.textContent = 'Nessun risultato con i filtri correnti.'; empty.style.color = '#6b7280'; empty.style.fontSize = '14px'; notesContainer.appendChild(empty);
            } else {
              names.forEach(folder => {
                const list = groups.get(folder) || []; list.sort((a,b)=> a.sortKey.localeCompare(b.sortKey, undefined, {sensitivity:'base'}));
                const fSection = document.createElement('section'); fSection.className = 'notes-section';
                const fHeader = document.createElement('div'); fHeader.className = 'section-header';
                const fBtn = document.createElement('button'); fBtn.className = 'collapse-btn';
                const isCollapsed = !!foldersCollapsed[folder]; fBtn.textContent = isCollapsed ? '>' : 'v'; fBtn.setAttribute('aria-expanded', String(!isCollapsed));
                const fTitle = document.createElement('h2'); fTitle.className = 'section-title'; fTitle.textContent = `Cartella: ${folder}`;
                fHeader.appendChild(fBtn); fHeader.appendChild(fTitle); fSection.appendChild(fHeader);
                const body = document.createElement('div'); body.style.display = isCollapsed ? 'none' : '';
                list.forEach(it => body.appendChild(it.node)); fSection.appendChild(body);
                const toggleFolder = ()=>{ const hidden = body.style.display !== 'none' ? true : false; body.style.display = hidden ? 'none' : ''; fBtn.textContent = hidden ? '>' : 'v'; fBtn.setAttribute('aria-expanded', String(!hidden)); foldersCollapsed[folder] = hidden; saveFoldersCollapsed(foldersCollapsed); };
                fBtn.addEventListener('click', toggleFolder);
                fTitle.addEventListener('click', toggleFolder);
                notesContainer.appendChild(fSection);
              });
            }
            return; // done grouped rendering
          }

          let currentFolder = null;
          let groupContainer = notesContainer;
          for (const item of sections) {
            const { doi, entry, title, folder } = item;
            if (groupByFolder) {
              if (folder !== currentFolder) {
                currentFolder = folder;
                const fSection = document.createElement('section');
                fSection.className = 'notes-section';
                const fHeader = document.createElement('div');
                fHeader.className = 'section-header';
                const fBtn = document.createElement('button');
                fBtn.className = 'collapse-btn';
                fBtn.textContent = 'v';
                fBtn.setAttribute('aria-expanded', 'true');
                const fTitle = document.createElement('h2');
                fTitle.className = 'section-title';
                fTitle.textContent = `Cartella: ${folder}`;
                fHeader.appendChild(fBtn);
                fHeader.appendChild(fTitle);
                fSection.appendChild(fHeader);
                groupContainer = document.createElement('div');
                fSection.appendChild(groupContainer);
                notesContainer.appendChild(fSection);
                fBtn.addEventListener('click', () => {
                  const hidden = groupContainer.style.display !== 'none' ? true : false;
                  groupContainer.style.display = hidden ? 'none' : '';
                  fBtn.textContent = hidden ? '>' : 'v';
                  fBtn.setAttribute('aria-expanded', String(!hidden));
                });
              }
            } else {
              groupContainer = notesContainer;
            }
            // Filtro testuale: match su titolo o dettagli
            const query = (filters.title || '').toLowerCase();
            const matchesText = !query || title.toLowerCase().includes(query) || detailsText(entry).includes(query);
            if (!matchesText) continue;

            const notes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
            // Ordina note per data (desc), se disponibile
            notes.sort((a, b) => {
              const ta = a && a.createdAt ? new Date(a.createdAt).getTime() : 0;
              const tb = b && b.createdAt ? new Date(b.createdAt).getTime() : 0;
              return tb - ta;
            });

            const visible = notes.filter(n => matchesFilters(entry, n));
            const count = visible.length;

            // Decide if this section should be shown
            const advancedActive = (filters.types.size || filters.tags.size || filters.animals.size || filters.methods.size);
            if (advancedActive && count === 0) continue;

            const section = document.createElement('section');
            section.className = 'notes-section';

            const header = document.createElement('div');
            header.className = 'section-header';
            const h = document.createElement('h2');
            h.className = 'section-title clickable';
            h.setAttribute('tabindex', '0');
            h.addEventListener('click', () => openDetailsFor(doi));
            h.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); openDetailsFor(doi); } });
            const btn = document.createElement('button');
            btn.className = 'collapse-btn';
            const collapsed = !!collapsedMap[doi];
            btn.setAttribute('aria-expanded', String(!collapsed));
            btn.textContent = collapsed ? '>' : 'v';
            header.appendChild(btn);
            // Add icon + caption for collapsed view
            const icon = document.createElement('div'); icon.className = 'article-icon'; icon.textContent = '📄';
            const caption = document.createElement('div'); caption.className = 'article-caption';
            // Color by folder
            try { const fName = folderLabelOf(entry); const fc = folderColorMap.get(fName) || folderColorMap.get('Senza cartella'); if (fc){ icon.style.borderColor = fc.border; icon.style.background = fc.bg; } } catch(_){}
            // Short caption without count
            caption.textContent = title;
            // Populate header based on state later
            function applyHeaderLayout() {
              header.innerHTML = '';
              header.appendChild(btn);
              if (section.classList.contains('collapsed')) {
                header.classList.add('collapsed-tile');
                header.appendChild(icon);
                header.appendChild(caption);
              } else {
                header.classList.remove('collapsed-tile');
                const titleEl = document.createElement('h2');
                titleEl.className = 'section-title clickable';
                titleEl.textContent = `${title} (${count})`;
                titleEl.setAttribute('tabindex', '0');
                titleEl.addEventListener('click', () => openDetailsFor(doi));
                titleEl.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); openDetailsFor(doi); } });
                header.appendChild(titleEl);
                // Show folder chip if present
                if (entry && entry.cartella) {
                  const fchip = document.createElement('span');
                  fchip.className = 'chip';
                  fchip.textContent = `Cartella: ${entry.cartella}`;
                  header.appendChild(fchip);
                }
              }
              // Actions (add note, variables)
              const actions = document.createElement('div');
              actions.className = 'header-actions';

              // Cerca DOI: apre una nuova scheda con una ricerca del DOI
              const searchDoiBtn = document.createElement('button');
              searchDoiBtn.className = 'btn';
              searchDoiBtn.textContent = 'Cerca DOI';
              searchDoiBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const url = `https://www.google.com/search?q=${encodeURIComponent(doi)}`;
                try { window.open(url, '_blank', 'noopener'); } catch (_) {}
              });

              // Copia DOI: copia negli appunti con fallback
              const copyDoiBtn = document.createElement('button');
              copyDoiBtn.className = 'btn';
              copyDoiBtn.textContent = 'Copia DOI';
              copyDoiBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const text = String(doi || '');
                let ok = false;
                try {
                  if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    ok = true;
                  }
                } catch (_) {}
                if (!ok) {
                  try {
                    const ta = document.createElement('textarea');
                    ta.value = text; ta.style.position = 'fixed'; ta.style.left = '-9999px';
                    document.body.appendChild(ta);
                    ta.focus(); ta.select();
                    ok = document.execCommand('copy');
                    document.body.removeChild(ta);
                  } catch (_) { ok = false; }
                }
                if (ok) { if (window.Toast && Toast.success) Toast.success('DOI copiato'); }
                else { if (window.Toast && Toast.error) Toast.error('Impossibile copiare il DOI'); }
              });

              actions.appendChild(searchDoiBtn);
              actions.appendChild(copyDoiBtn);
              // Cited by (if any)
              try {
                const normSelf = normalizeDoi(doi);
                const set = normSelf ? (citedBy.get(normSelf) || new Set()) : new Set();
                const countCited = set.size;
                if (countCited > 0) {
                  const cbBtn = document.createElement('button');
                  cbBtn.className = 'btn';
                  cbBtn.textContent = `Cited by (${countCited})`;
                  cbBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const nodes = [];
                    const list = Array.from(set);
                    list.forEach(normCiting => {
                      const key = doiIndex.get(normCiting) || normCiting;
                      const ent = db[key];
                      const t = getTitle(ent) || key;
                      const row = document.createElement('div'); row.className='ref-row';
                      const d1 = document.createElement('div'); d1.textContent = t; row.appendChild(d1);
                      const d2 = document.createElement('div'); d2.className='muted'; d2.textContent = key; row.appendChild(d2);
                      const a = Object.assign(document.createElement('a'), { href:`details.html?doi=${encodeURIComponent(key)}`, textContent:'Apri' }); row.appendChild(a);
                      nodes.push(row);
                    });
                    openOverlay('Articoli che citano questo DOI', nodes);
                  });
                  actions.appendChild(cbBtn);
                }
              } catch (_) {}
              const addNoteBtn = document.createElement('button');
              addNoteBtn.className = 'btn';
              addNoteBtn.textContent = 'Aggiungi nota';
              addNoteBtn.addEventListener('click', (e) => { e.stopPropagation(); window.location.href = `notes.html?doi=${encodeURIComponent(doi)}`; });
              const varsBtn = document.createElement('button');
              varsBtn.className = 'btn';
              varsBtn.textContent = 'Variabili';
              varsBtn.addEventListener('click', (e) => { e.stopPropagation(); window.location.href = `variabili.html?doi=${encodeURIComponent(doi)}`; });
              // Assign folder button
              const assignFolderBtn = document.createElement('button');
              assignFolderBtn.className = 'btn';
              assignFolderBtn.textContent = 'Assegna cartella';
              assignFolderBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                try {
                  const full = await DataService.getAll();
                  const base = full[doi] || { DOI: doi };
                  const def = (base && base.cartella) || getLastFolder();
                  // Build existing folders list
                  const fset = new Set();
                  try {
                    Object.keys(full||{}).forEach(k => { const v = String((full[k] && full[k].cartella) || '').trim(); if (v) fset.add(v); });
                  } catch (_) {}
                  const folders = Array.from(fset).sort((a,b)=> a.localeCompare(b, undefined, {sensitivity:'base'}));

                  // Build overlay content
                  const nodes = [];
                  const row = document.createElement('div'); row.className = 'row';
                  const lab = document.createElement('label'); lab.textContent = 'Cartella'; row.appendChild(lab);
                  const inp = Object.assign(document.createElement('input'), { type:'text', id:'folderAssignInput', value: def || '', placeholder:'es. Capitolo 1 / Energia' });
                  inp.setAttribute('list', 'folderDatalist');
                  row.appendChild(inp);
                  const dl = document.createElement('datalist'); dl.id = 'folderDatalist';
                  folders.forEach(f => { const op = document.createElement('option'); op.value = f; dl.appendChild(op); });
                  nodes.push(row); nodes.push(dl);
                  if (folders.length) {
                    const chips = document.createElement('div'); chips.className = 'chips';
                    folders.forEach(f => { const c=document.createElement('span'); c.className='chip'; c.textContent=f; c.style.cursor='pointer'; c.addEventListener('click', ()=>{ inp.value = f; }); chips.appendChild(c); });
                    nodes.push(chips);
                  }
                  const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='8px';
                  const saveB = Object.assign(document.createElement('button'), { className:'btn primary', type:'button', textContent:'Salva' });
                  const clearB = Object.assign(document.createElement('button'), { className:'btn', type:'button', textContent:'Rimuovi' });
                  const cancelB = Object.assign(document.createElement('button'), { className:'btn', type:'button', textContent:'Annulla' });
                  actions.appendChild(saveB); actions.appendChild(clearB); actions.appendChild(cancelB);
                  nodes.push(actions);
                  openOverlay('Assegna cartella', nodes);

                  const closeOverlay = () => { try { const back = document.getElementById('overlayBackdrop'); if (back) back.classList.remove('open'); } catch(_){} };
                  clearB.addEventListener('click', ()=> { inp.value = ''; inp.focus(); });
                  cancelB.addEventListener('click', closeOverlay);
                  inp.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter') saveB.click(); });
                  saveB.addEventListener('click', async () => {
                    const folder = String(inp.value || '').trim();
                    const combined = Object.assign({}, base);
                    if (folder) { combined.cartella = folder; setLastFolder(folder); } else { delete combined.cartella; }
                    showLoadingOverlay('Salvataggio cartella...');
                    try {
                      await DataService.saveRecord(doi, combined);
                      db[doi] = combined; // update local cache
                      renderNotes();
                      closeOverlay();
                      updateLoadingOverlay('Cartella salvata e lista aggiornata');
                      setTimeout(() => hideLoadingOverlay(), 700);
                    } catch (err) {
                      console.error('Assegna cartella fallito', err);
                      hideLoadingOverlay();
                      if (window.Toast && Toast.error) Toast.error('Errore salvataggio cartella');
                      alert('Errore durante il salvataggio');
                    }
                  });
                } catch (e) {
                  console.error('Assegna cartella init fallito', e);
                  if (window.Toast && Toast.error) Toast.error('Errore apertura dialog cartella');
                }
              });
              actions.appendChild(addNoteBtn);
              actions.appendChild(assignFolderBtn);
              actions.appendChild(varsBtn);
              // Show actions only in expanded view to keep tiles compact
              if (!section.classList.contains('collapsed')) {
                header.appendChild(actions);
              }
            }
            if (collapsed) section.classList.add('collapsed');
            applyHeaderLayout();
            section.appendChild(header);

            const grid = document.createElement('div');
            grid.className = 'notes-grid';
            if (collapsed) grid.style.display = 'none';

            // Details are not rendered inline; click title to open details popup

            if (count > 0) {
              for (const note of visible) {
                const card = createCard(doi, entry, note);
                grid.appendChild(card);
              }
            } else if (!collapsed) {
              const placeholder = document.createElement('div');
              placeholder.textContent = 'Nessuna nota per questo articolo.';
              placeholder.style.color = '#6b7280';
              placeholder.style.fontSize = '14px';
              // Usa tutta la riga
              placeholder.style.gridColumn = '1 / -1';
              grid.appendChild(placeholder);
            }

            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const nowCollapsed = grid.style.display !== 'none' ? true : false;
              grid.style.display = nowCollapsed ? 'none' : '';
              section.classList.toggle('collapsed', nowCollapsed);
              btn.textContent = nowCollapsed ? '>' : 'v';
              btn.setAttribute('aria-expanded', String(!nowCollapsed));
              collapsedMap[doi] = nowCollapsed;
              saveCollapsed(collapsedMap);
              applyHeaderLayout();
            });

            section.appendChild(grid);
            groupContainer.appendChild(section);
          }
        }

        async function editNote(doi, note) {
          if (!doi) return;
          const id = note && note.id;
          const ts = note && note.createdAt;
          if (id) {
            window.location.href = `notes.html?doi=${encodeURIComponent(doi)}&id=${encodeURIComponent(id)}`;
            return;
          }
          if (ts) {
            window.location.href = `notes.html?doi=${encodeURIComponent(doi)}&ts=${encodeURIComponent(ts)}`;
            return;
          }
          // fallback: open create for that DOI
          window.location.href = `notes.html?doi=${encodeURIComponent(doi)}`;
        }

        async function openDetailsFor(doi) {
          if (!doi) return;
          window.location.href = `details.html?doi=${encodeURIComponent(doi)}`;
        }

        // Initial load
        loadAll();

        // Nessun listener messaggi dal popup: popup disabilitato
      })();
    </script>
  </body>
  </html>
