<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Nota Articolo</title>
    <link rel="stylesheet" href="project/assets/css/style.css" />
    <script src="project/assets/js/dataService.js"></script>
    <script src="project/assets/js/toast.js"></script>
    <style>
      :root { --gap: 12px; --border: 1px solid #e5e7eb; --radius: 12px; }
      body { margin: 2rem; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color: #111827; }
      a { color: #2563eb; text-decoration: none; }
      a:hover { text-decoration: underline; }
      .header { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; margin-bottom: 16px; }
      .title { margin: 0; font-size: 22px; }
      .sub { color: #6b7280; font-size: 13px; }
      .toolbar { display: flex; gap: 8px; align-items: center; }
      .btn { font-size: 14px; padding: 8px 12px; border-radius: 8px; border: 1px solid #d0d0d0; background: #fff; cursor: pointer; }
      .btn:hover { background: #f6f6f6; }
      .primary { background: #2563eb; border-color: #2563eb; color: #fff; }

      .layout { display: grid; grid-template-columns: 1fr; gap: 16px; }
      .panel { padding: 12px; border: var(--border); border-radius: var(--radius); background: #fff; display:grid; gap:12px; }
      .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
      .grid-1 { display: grid; grid-template-columns: 1fr; gap: 10px; }
      label { font-size: 12px; color: #374151; }
      input[type="text"], input[type="url"], textarea, select { width: 100%; padding: 8px 10px; border: 1px solid #d0d0d0; border-radius: 8px; font-size: 14px; box-sizing: border-box; }
      textarea { resize: vertical; }
      .row { display: grid; gap: 6px; }
      .steps-panel { display: grid; gap: 16px; }
      .stepper { display: flex; gap: 8px; flex-wrap: wrap; }
      .step-pill { padding: 6px 10px; border: 1px solid #d0d0d0; border-radius: 9999px; background: #f8fafc; font-size: 12px; }
      .step-pill.current { background: #2563eb; color: #fff; border-color: #2563eb; }
      .step-pill.done { background: #e0f2fe; border-color: #bfdbfe; color: #1e3a8a; }
      .step { display: none; gap: 12px; }
      .step.active { display: grid; }
      .step-title { margin: 0; font-size: 16px; }
      .steps-nav { display: flex; gap: 8px; align-items: center; justify-content: flex-end; border-top: 1px solid #e5e7eb; padding-top: 12px; }

      /* Evidenzia le lettere separatrici nell'elenco dei tag */
      .chip.letter-sep {
        font-weight: 700;
        font-size: 16px;
        padding: 6px 12px;
        background: #eef2f7;
        border: 1px solid #cbd5e1;
        color: #0f172a;
      }

      /* Loading overlay */
      .loading-backdrop { position: fixed; inset:0; background: rgba(0,0,0,0.25); display: none; align-items: center; justify-content: center; z-index: 200; }
      .loading-backdrop.open { display: flex; }
      .loading-box { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:16px 20px; min-width:260px; display:grid; gap:10px; align-items:center; justify-items:center; box-shadow: 0 20px 50px rgba(0,0,0,0.15); }
      .spinner { width:28px; height:28px; border:3px solid #e5e7eb; border-top:3px solid #2563eb; border-radius:50%; animation: spin 0.8s linear infinite; }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
  </head>
  <body>
    <div class="header">
      <div>
        <h1 class="title" id="pageTitle">Nuova nota</h1>
        <div class="sub" id="pageSub"></div>
      </div>
      <div class="toolbar">
        <a class="btn" href="index.html">< Torna</a>
      </div>
    </div>

    <div class="panel steps-panel">
      <div class="row">
        <label for="doiSelect">Articolo (DOI)</label>
        <select id="doiSelect"></select>
      </div>

      <div class="stepper" aria-label="Passaggi compilazione">
        <div class="step-pill current" data-step="1">1. Testo</div>
        <div class="step-pill" data-step="2">2. Tipo & tag</div>
        <div class="step-pill" data-step="3">3. Dettagli</div>
      </div>

      <div class="step active" data-step="1">
        <h2 class="step-title">Step 1 - Testo e importanza</h2>
        <div class="row">
          <label for="noteText">Testo nota</label>
          <div class="grid-1">
            <label style="display:inline-flex; align-items:center; gap:8px; font-weight: normal;">
              <input id="extractToggle" type="checkbox" checked />
              Estrai testo da URL
            </label>
            <textarea id="noteText" rows="6" placeholder="Verrà estratto dal parametro #:~:text dell'URL" readonly></textarea>
          </div>
        </div>
        <div class="row">
          <label for="commentInput">Commento</label>
          <textarea id="commentInput" rows="2" placeholder="Commento aggiuntivo..."></textarea>
        </div>
        <div class="grid">
          <div class="row">
            <label for="importanceRange">Importanza (1-10)</label>
            <div style="display:flex; align-items:center; gap:8px;">
              <input id="importanceRange" type="range" min="1" max="10" step="1" value="1" style="flex:1;" />
              <input id="importanceNumber" type="number" min="1" max="10" step="1" value="1" style="width:70px;" />
            </div>
          </div>
          <div class="row">
            <label>Anteprima colore</label>
            <div id="importancePreview" style="height:36px; border-radius:8px; border:1px solid #d0d0d0;"></div>
          </div>
        </div>
      </div>

      <div class="step" data-step="2">
        <h2 class="step-title">Step 2 - Tipo, tag e animali</h2>
        <div class="row">
          <label for="typeInput">Tipo</label>
          <input id="typeInput" type="text" list="typeList" placeholder="es. commento, riassunto, to-do" />
          <datalist id="typeList">
            <option value="commento"></option>
            <option value="riassunto"></option>
            <option value="promemoria"></option>
            <option value="citazione"></option>
            <option value="idea"></option>
            <option value="domanda"></option>
          </datalist>
          <select id="typeSelect"></select>
          <div id="typeChips" class="chips" style="margin-top:6px;"></div>
        </div>
        <div class="grid">
          <div class="row">
            <label for="tagsInput">Tag (separati da virgola)</label>
            <input id="tagsInput" type="text" placeholder="es. energy, ecology, hydropower" />
            <div id="tagChips" class="chips" style="margin-top:6px;"></div>
          </div>
          <div class="row">
            <label for="animalsInput">Animali (separati da virgola)</label>
            <input id="animalsInput" type="text" placeholder="es. lupo, orso, lince" />
            <select id="animalsSelect"></select>
            <div id="animalChips" class="chips" style="margin-top:6px;"></div>
          </div>
        </div>
      </div>

      <div class="step" data-step="3">
        <h2 class="step-title">Step 3 - Dettagli aggiuntivi</h2>
        <div class="grid">
          <div class="row">
            <label for="urlInput">URL (con selezione testo)</label>
            <input id="urlInput" type="url" placeholder="https://...#:~:text=..." />
          </div>
          <div class="row">
            <label for="imageUrlInput">URL immagine</label>
            <input id="imageUrlInput" type="url" placeholder="https://.../image.png" />
          </div>
        </div>

        <div class="row">
          <label for="referencesInput">References (DOI; separati da ;)</label>
          <input id="referencesInput" type="text" placeholder="es. 10.1038/nphys1170; 10.1016/j.ecolmodel.2018.01.012" />
          <div class="sub">Suggerimento formato: 10.xxxx/..... Accetta anche https://doi.org/... o doi:...</div>
        </div>

        <!-- Glossario (opzionale, supporta più termini) -->
        <div class="row">
          <details id="glossaryBox">
            <summary style="cursor:pointer; user-select:none;">
              <label style="display:inline-flex; align-items:center; gap:8px; font-weight: normal;">
                <input id="glossaryEnabled" type="checkbox" />
                Glossario (opzionale)
              </label>
            </summary>
            <div class="row">
              <div style="display:flex; align-items:center; gap:8px;">
                <button id="addGlossaryRow" class="btn" type="button">+ Aggiungi termine</button>
              </div>
            </div>
            <div id="glossaryList" class="grid-1"></div>
            <div class="row">
              <div style="font-size:12px; color:#6b7280;">Le voci saranno legate a DOI, Tipo, Tag e Importanza impostati sopra.</div>
            </div>
          </details>
        </div>
      </div>

      <div class="steps-nav">
        <button id="prevStepBtn" class="btn" type="button">Indietro</button>
        <button id="nextStepBtn" class="btn" type="button">Avanti</button>
        <button id="saveBtn" class="btn primary" type="button">Salva nota</button>
      </div>
    </div>

    <script>
      (function(){
        const doiSelect = document.getElementById('doiSelect');
        const pageTitle = document.getElementById('pageTitle');
        const pageSub = document.getElementById('pageSub');
        const saveBtn = document.getElementById('saveBtn');
        const typeInput = document.getElementById('typeInput');
        const typeSelect = document.getElementById('typeSelect');
        const tagsInput = document.getElementById('tagsInput');
        const urlInput = document.getElementById('urlInput');
        const imageUrlInput = document.getElementById('imageUrlInput');
        const animalsInput = document.getElementById('animalsInput');
        const commentInput = document.getElementById('commentInput');
        const referencesInput = document.getElementById('referencesInput');
        const noteText = document.getElementById('noteText');
        const extractToggle = document.getElementById('extractToggle');
        const steps = Array.from(document.querySelectorAll('.step'));
        const stepPills = Array.from(document.querySelectorAll('.step-pill'));
        const prevStepBtn = document.getElementById('prevStepBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        let currentStep = 1;
        // Glossario (multi-rows)
        const glossaryEnabled = document.getElementById('glossaryEnabled');
        const glossaryList = document.getElementById('glossaryList');
        const addGlossaryRow = document.getElementById('addGlossaryRow');

        function updateStepUI(){
          steps.forEach(step => {
            const s = Number(step.dataset.step || '0');
            step.classList.toggle('active', s === currentStep);
          });
          stepPills.forEach(pill => {
            const s = Number(pill.dataset.step || '0');
            pill.classList.toggle('current', s === currentStep);
            pill.classList.toggle('done', s < currentStep);
          });
          if (prevStepBtn) prevStepBtn.disabled = currentStep === 1;
          if (nextStepBtn) {
            nextStepBtn.disabled = currentStep === steps.length;
            nextStepBtn.textContent = currentStep === steps.length ? 'Rivedi' : 'Avanti';
          }
        }

        function goToStep(n){
          if (!steps.length) return;
          currentStep = Math.max(1, Math.min(steps.length, n));
          updateStepUI();
          try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch(_) {}
        }

        function addGlossRow(data={}){
          const row = document.createElement('div');
          row.className = 'gloss-row';
          row.style.border = '1px solid #e5e7eb';
          row.style.borderRadius = '8px';
          row.style.padding = '8px';
          row.style.marginTop = '8px';
          const hid = document.createElement('input'); hid.type = 'hidden'; hid.className = 'gloss-id'; hid.value = data.id || ''; row.appendChild(hid);
          const grid = document.createElement('div'); grid.className = 'grid';
          const r1 = document.createElement('div'); r1.className = 'row';
          r1.appendChild(Object.assign(document.createElement('label'), { textContent: 'Termine' }));
          const term = Object.assign(document.createElement('input'), { type: 'text', placeholder: 'Nome del termine' }); term.className = 'gloss-term'; term.value = data.term || ''; r1.appendChild(term);
          const r2 = document.createElement('div'); r2.className = 'row';
          r2.appendChild(Object.assign(document.createElement('label'), { textContent: 'Significato' }));
          const meaning = Object.assign(document.createElement('textarea'), { rows: 3, placeholder: 'Definizione del termine' }); meaning.className = 'gloss-meaning'; meaning.value = data.meaning || ''; r2.appendChild(meaning);
          grid.appendChild(r1); grid.appendChild(r2);
          row.appendChild(grid);
          const controls = document.createElement('div'); controls.className = 'row'; controls.style.display = 'flex'; controls.style.justifyContent = 'flex-end';
          const del = Object.assign(document.createElement('button'), { className:'btn', type:'button', textContent:'Rimuovi' });
          del.addEventListener('click', () => row.remove());
          controls.appendChild(del); row.appendChild(controls);
          glossaryList.appendChild(row);
        }

        function collectGlossRows(){
          const out = [];
          if (!glossaryList) return out;
          const rows = glossaryList.querySelectorAll('.gloss-row');
          rows.forEach(r => {
            const id = (r.querySelector('.gloss-id') && r.querySelector('.gloss-id').value) || '';
            const term = (r.querySelector('.gloss-term') && r.querySelector('.gloss-term').value) || '';
            const meaning = (r.querySelector('.gloss-meaning') && r.querySelector('.gloss-meaning').value) || '';
            if ((term && term.trim()) || (meaning && meaning.trim())) {
              out.push({ id: id || null, term: term.trim(), meaning: meaning.trim() });
            }
          });
          return out;
        }
        const typeChips = document.getElementById('typeChips');
        const tagChips = document.getElementById('tagChips');
        const animalChips = document.getElementById('animalChips');
        const animalsSelect = document.getElementById('animalsSelect');

        const params = new URLSearchParams(location.search);
        const initialDOI = params.get('doi') || '';
        const rawId = params.get('id');
        const noteId = (rawId && rawId !== 'undefined') ? rawId : '';
        const noteTs = params.get('ts') || '';

        let db = {};
        let currentEntry = null;
        let editingNote = null;
        let facets = { types: [], tags: [], animals: [] };
        const DEFAULT_TYPES = ['commento','riassunto','promemoria','citazione','idea','domanda'];

        function splitCsv(str){ return (str||'').split(',').map(s=>s.trim()).filter(Boolean); }

        function extractTextFragment(rawUrl){
          try {
            if (!rawUrl) return '';
            const url = String(rawUrl);
            const hashIndex = url.indexOf('#:~:');
            if (hashIndex === -1) return '';
            const fragment = url.slice(hashIndex + 4); // starts with :~:
            // Build a URLSearchParams-like map for the text fragment part
            // Expect pattern like :~:text=...&text=...
            const paramsPart = fragment.replace(/^:\~:/, '');
            const parts = paramsPart.split('&');
            const texts = [];
            for (const p of parts) {
              const [k, vRaw] = p.split('=');
              if (k !== 'text') continue;
              // value can contain commas to denote contexts; decode fully
              const v = decodeURIComponent((vRaw || '').replace(/\+/g, ' '));
              if (!v) continue;
              // If it contains prefix-/ -suffix markers, try to extract middle segment
              // Common patterns: prefix-,EXACT,-suffix  or EXACT  or start,end
              const mid = v.split(',-').length > 1 || v.split('-,').length > 1 ? v.replace(/.*-,\s*/,'').replace(/\s*,-.*/,'') : v;
              texts.push(mid);
            }
            if (texts.length) return texts.join(' … ');
            // Fallback: if there's a single text= param in the whole hash
            const m = url.match(/#:~:text=([^&]+)/);
            if (m && m[1]) return decodeURIComponent(m[1].replace(/\+/g,' '));
            return '';
          } catch (_) { return ''; }
        }

        let extractFromUrl = true;
        const importanceRange = document.getElementById('importanceRange');
        const importanceNumber = document.getElementById('importanceNumber');
        const importancePreview = document.getElementById('importancePreview');

        function clampImportanza(v){
          const n = parseInt(v, 10);
          if (isNaN(n)) return 1;
          return Math.max(1, Math.min(10, n));
        }

        function normalizeDoi(raw){
          if (!raw) return '';
          try {
            let s = String(raw).trim();
            s = s.replace(/^https?:\/\/(dx\.)?doi\.org\//i,'');
            s = s.replace(/^doi:\s*/i,'');
            const full = s.match(/10\.\d{4,9}\/[^\s;]+/i);
            const core = full ? full[0] : ( /^10\.\d{4,9}\/\S+$/i.test(s) ? s : '' );
            return core ? core.toLowerCase() : '';
          } catch(_) { return ''; }
        }

        function prepareReferencesString(input){
          const parts = String(input||'').split(';').map(x=>normalizeDoi(x)).filter(Boolean);
          const uniq = Array.from(new Set(parts));
          return uniq.join('; ');
        }

        function importanceToColor(val){
          const v = clampImportanza(val);
          const hue = 55 - (v - 1) * (55 / 9); // from ~yellow to red
          const sat = 78 + (v - 1) * (20 / 9); // 78% -> ~98%
          const light = 96 - (v - 1) * (9 / 9); // 96% -> 87%
          return `hsl(${hue.toFixed(1)} ${sat.toFixed(1)}% ${light.toFixed(1)}%)`;
        }

        function updateImportancePreview(){
          const v = clampImportanza(importanceRange.value || importanceNumber.value || 1);
          importancePreview.style.background = importanceToColor(v);
        }

        function syncImportance(from){
          if (from === 'range') {
            importanceNumber.value = clampImportanza(importanceRange.value);
          } else {
            importanceRange.value = clampImportanza(importanceNumber.value);
          }
          updateImportancePreview();
        }

        importanceRange.addEventListener('input', () => syncImportance('range'));
        importanceNumber.addEventListener('input', () => syncImportance('number'));

        function applyToggleState(){
          extractFromUrl = !!extractToggle.checked;
          noteText.readOnly = extractFromUrl;
          noteText.placeholder = extractFromUrl
            ? "Verrà estratto dal parametro #:~:text dell'URL"
            : "Scrivi il testo della nota...";
          if (extractFromUrl) {
            refreshExtractedText(true);
          }
        }

        function refreshExtractedText(force=false){
          if (!extractFromUrl && !force) return;
          const t = extractTextFragment(urlInput.value);
          noteText.value = t || '';
        }

        function getTitle(entry){
          if(!entry) return '';
          const t = entry.title;
          if(Array.isArray(t)&&t.length) return t.join(' — ');
          if(typeof t==='string') return t;
          return '';
        }

        async function loadAll(){
          try {
            db = await DataService.getAll();
            const dois = Object.keys(db);
            console.log('[notes] DOIs caricati:', dois.length);
            if (dois.length === 0 && Toast && Toast.info) {
              Toast.info('Nessun articolo trovato. Aggiungi un DOI prima di creare note.');
            }
          } catch(e){ db = {}; }
          computeFacets();
          renderFacetChips();
          renderFacetSelects();
          renderTypeSelect();
          populateDOIs();
          if (initialDOI) {
            const idx = Object.keys(db).indexOf(initialDOI);
            if (idx >= 0) doiSelect.value = initialDOI;
          }
          onDOIChange();
          if (noteId || noteTs) prefillForEdit(noteId);
        }

        function computeFacets(){
          const types = new Set();
          const animals = new Set();
          const tagDisplay = new Map(); // normalized -> display label
          for (const doi of Object.keys(db)){
            const entry = db[doi];
            const notes = Array.isArray(entry?.user_notes) ? entry.user_notes : (entry?.user_note ? [entry.user_note] : []);
            for (const n of notes){
              if (!n) continue;
              if (n.type) types.add(String(n.type));
              const ts = Array.isArray(n.tags) ? n.tags : (n.tags ? [String(n.tags)] : []);
              ts.forEach(t=>{ const disp=String(t).trim(); const k=disp.toLowerCase(); if(!tagDisplay.has(k)) tagDisplay.set(k, disp); });
              (Array.isArray(n.animals) ? n.animals : (n.animals ? [String(n.animals)] : [])).forEach(a=>animals.add(String(a)));
            }
          }
          const tags = Array.from(tagDisplay.values()).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'}));
          facets = {
            types: Array.from(types).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'})),
            tags,
            animals: Array.from(animals).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'})),
          };
        }

        function tagKey(s){ return String(s||'').trim().toLowerCase(); }
        function applyTagChipStyle(el, tag, counts, max){
          try {
            const c = (counts && counts[tagKey(tag)]) || 0;
            if (!max) return;
            const t = Math.max(0, Math.min(1, c / max));
            const light = 98 - Math.round(t * 40); // 98 -> 58 (più scuro se frequente)
            const sat = 85;
            el.style.background = `hsl(0 ${sat}% ${light}%)`;
            el.style.color = (light < 75) ? '#fff' : '#7f1d1d';
          } catch (_) {}
        }

        function appendCsv(inputEl, value){
          const cur = (inputEl.value||'');
          const list = cur ? cur.split(',').map(s=>s.trim()).filter(Boolean) : [];
          if (!list.map(s=>s.toLowerCase()).includes(String(value).toLowerCase())) list.push(String(value));
          inputEl.value = list.join(', ');
        }

        function addOrReplaceLastCsv(inputEl, value){
          const raw = String(inputEl.value||'');
          const tokens = raw.split(',');
          const hasTrailingComma = /,\s*$/.test(raw);
          const selected = String(value);
          if (hasTrailingComma || tokens.length === 0) {
            // Simple append when last char is comma or empty
            appendCsv(inputEl, selected);
            return;
          }
          // Replace last partial token
          const head = tokens.slice(0, -1).map(s=>s.trim()).filter(Boolean);
          const out = head.concat([selected]);
          // Deduplicate case-insensitively, keeping first occurrences in order
          const seen = new Set();
          const uniq = [];
          for (const t of out) {
            const L = t.toLowerCase();
            if (seen.has(L)) continue;
            seen.add(L); uniq.push(t);
          }
          inputEl.value = uniq.join(', ');
        }

        function renderFacetChips(){
          const counts = computeTagsCount(db);
          const max = (()=>{ try { return Object.values(counts||{}).reduce((m,v)=>Math.max(m, v||0), 0); } catch(_) { return 0; } })();
          // Types (no filtering)
          typeChips.innerHTML = '';
          facets.types.forEach(t=>{ const s=document.createElement('span'); s.className='chip'; s.textContent=t; s.onclick=()=>{ typeInput.value = t; }; typeChips.appendChild(s); });

          // Tags (filtered by last partial token typed in tagsInput)
          tagChips.innerHTML = '';
          const raw = (tagsInput.value || '');
          const lastToken = raw.split(',').pop().trim().toLowerCase();
          const list = lastToken ? facets.tags.filter(t => t.toLowerCase().includes(lastToken)) : facets.tags;
          if (list.length === 0 && lastToken) {
            const m = document.createElement('div');
            m.className = 'small';
            m.textContent = 'Nessun tag corrispondente';
            tagChips.appendChild(m);
          } else {
            // alphabetical separators
            let prevLetter = null;
            list.forEach(t=>{
              const first = (String(t).trim()[0]||'').toUpperCase();
              const letter = (first && first >= 'A' && first <= 'Z') ? first : '#';
              if (letter !== prevLetter) {
                const sep = document.createElement('span');
                sep.className='chip letter-sep';
                sep.textContent = letter;
                sep.title = `Inizio ${letter}`;
                sep.setAttribute('role','separator');
                sep.setAttribute('aria-label', `Sezione ${letter}`);
                tagChips.appendChild(sep);
                prevLetter = letter;
              }
              const s=document.createElement('span'); s.className='chip tag';
              const cnt = (counts && counts[tagKey(t)]) || 0;
              s.textContent = `${t} (${cnt})`;
              applyTagChipStyle(s, t, counts, max);
              s.onclick=()=> { addOrReplaceLastCsv(tagsInput, t); renderFacetChips(); };
              tagChips.appendChild(s);
            });
          }

          // Animals (no filtering)
          animalChips.innerHTML = '';
          facets.animals.forEach(a=>{ const s=document.createElement('span'); s.className='chip animal'; s.textContent=a; s.onclick=()=> appendCsv(animalsInput, a); animalChips.appendChild(s); });
        }

        function renderTypeSelect(){
          const set = new Set([ ...DEFAULT_TYPES, ...facets.types ]);
          const arr = Array.from(set).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'}));
          typeSelect.innerHTML = '';
          const empty = document.createElement('option'); empty.value=''; empty.textContent='— Seleziona tipo —'; typeSelect.appendChild(empty);
          arr.forEach(v => { const op = document.createElement('option'); op.value = v; op.textContent = v; typeSelect.appendChild(op); });
          typeSelect.onchange = () => { typeInput.value = typeSelect.value || ''; };
        }

        function renderFacetSelects(){
          // Animals select (appende al campo, poi resetta)
          animalsSelect.innerHTML = '';
          const optEmptyA = document.createElement('option'); optEmptyA.value=''; optEmptyA.textContent='- Aggiungi animale -'; animalsSelect.appendChild(optEmptyA);
          facets.animals.forEach(a=>{ const op=document.createElement('option'); op.value=a; op.textContent=a; animalsSelect.appendChild(op); });
          animalsSelect.onchange = () => { if (animalsSelect.value) { appendCsv(animalsInput, animalsSelect.value); animalsSelect.value = ''; } };
        }

        function populateDOIs(){
          const dois = Object.keys(db).sort((a,b)=>a.localeCompare(b));
          doiSelect.innerHTML = '';
          for (const doi of dois){
            const opt = document.createElement('option');
            opt.value = doi; opt.textContent = (db[doi]?.title?.[0]) || doi;
            doiSelect.appendChild(opt);
          }
        }

        function onDOIChange(){
          const doi = doiSelect.value;
          currentEntry = db[doi] || null;
          pageTitle.textContent = (noteId || noteTs) ? 'Modifica nota' : 'Nuova nota';
          pageSub.textContent = doi ? ('DOI: ' + doi) : '';
        }
        doiSelect.addEventListener('change', onDOIChange);

        function prefillForEdit(id){
          if (!currentEntry) return;
          const notes = Array.isArray(currentEntry.user_notes) ? currentEntry.user_notes : (currentEntry.user_note ? [currentEntry.user_note] : []);
          let n = null;
          if (id) n = notes.find(x => x && x.id === id);
          if (!n && noteTs) n = notes.find(x => x && x.createdAt === noteTs);
          if (!n) return;
          editingNote = n;
          typeInput.value = n.type || '';
          // Try to select in dropdown as well
          if (typeSelect) {
            const opts = Array.from(typeSelect.options).map(o=>o.value);
            typeSelect.value = opts.includes(n.type) ? n.type : '';
          }
          tagsInput.value = Array.isArray(n.tags) ? n.tags.join(', ') : (n.tags || '');
          urlInput.value = n.url || '';
          imageUrlInput.value = n.imageUrl || '';
          animalsInput.value = Array.isArray(n.animals) ? n.animals.join(', ') : (n.animals || '');
          commentInput.value = n.comment || '';
          referencesInput.value = n.references || '';
          const imp = clampImportanza(n.importanza == null ? 1 : n.importanza);
          importanceRange.value = imp;
          importanceNumber.value = imp;
          updateImportancePreview();
          // Re-estrai il testo dall'URL per coerenza; se vuoto ma esiste testo salvato, abilita editing manuale
          refreshExtractedText(true);
          if (!noteText.value && n.text) {
            extractToggle.checked = false;
            applyToggleState();
            noteText.value = n.text || '';
          }
        }
          // Prefill glossary rows linked to this note
          try {
            if (glossaryList) glossaryList.innerHTML = '';
            const gArr = Array.isArray(currentEntry.user_glossario) ? currentEntry.user_glossario : [];
            const list = gArr.filter(x => x && (x.sourceNoteId === n.id || x.createdAt === n.createdAt));
            if (list.length && glossaryEnabled) {
              glossaryEnabled.checked = true;
              const box = document.getElementById('glossaryBox');
              if (box && !box.open) box.open = true;
              list.forEach(g => addGlossRow({ id: g.id, term: g.term, meaning: g.meaning }));
            }
          } catch (_) {}
        }

        urlInput.addEventListener('input', () => refreshExtractedText());
        urlInput.addEventListener('change', () => refreshExtractedText());
        extractToggle.addEventListener('change', applyToggleState);
        tagsInput.addEventListener('input', () => renderFacetChips());

        // Loading overlay helpers (local to this page)
        function ensureLoadingOverlay(){
          let back = document.getElementById('loadingBackdrop');
          if (!back) {
            back = document.createElement('div'); back.id='loadingBackdrop'; back.className='loading-backdrop';
            const box = document.createElement('div'); box.className='loading-box'; box.id='loadingBox';
            const sp = document.createElement('div'); sp.className='spinner'; box.appendChild(sp);
            const msg = document.createElement('div'); msg.id='loadingLabel'; msg.style.fontSize='14px'; msg.textContent=''; box.appendChild(msg);
            back.appendChild(box); document.body.appendChild(back);
          }
          return back;
        }
        function showLoadingOverlay(message){ const back = ensureLoadingOverlay(); const lab = document.getElementById('loadingLabel'); if (lab) lab.textContent = message || 'Salvataggio...'; back.classList.add('open'); }
        function updateLoadingOverlay(message){ const lab = document.getElementById('loadingLabel'); if (lab) lab.textContent = message || ''; }
        function hideLoadingOverlay(){ try { const back = document.getElementById('loadingBackdrop'); if (back) back.classList.remove('open'); } catch(_){} }

        async function save(){
          const doi = doiSelect.value;
          if (!doi) { alert('Seleziona un DOI'); return; }
          if (extractFromUrl) {
            if (!urlInput.value) { alert('Inserisci un URL contenente la selezione del testo (#:~:text=...)'); return; }
            // Assicurati che il testo sia aggiornato dall'URL
            refreshExtractedText(true);
          }
          try {
            showLoadingOverlay('Salvataggio nota...');
            const full = await DataService.getAll();
            const base = full[doi] || { DOI: doi };
            const combined = Object.assign({}, base);
            const notesArr = Array.isArray(combined.user_notes) ? combined.user_notes : [];
            if (!Array.isArray(combined.user_notes) && combined.user_note) {
              notesArr.push(Object.assign({}, combined.user_note));
              delete combined.user_note;
            }

            const now = new Date().toISOString();
            const enriched = Object.assign(
              {
                id: (editingNote && editingNote.id) || (crypto.randomUUID ? crypto.randomUUID() : ('note_' + Date.now().toString(36))),
                doi,
                text: extractFromUrl ? (noteText.value || extractTextFragment(urlInput.value) || '') : (noteText.value || ''),
                type: (typeInput.value || '').trim() || null,
                tags: splitCsv(tagsInput.value),
                url: (urlInput.value || '').trim() || null,
                imageUrl: (imageUrlInput.value || '').trim() || null,
                comment: (commentInput.value || '').trim() || null,
                animals: splitCsv(animalsInput.value),
                references: prepareReferencesString(referencesInput.value || ''),
                importanza: clampImportanza(importanceRange.value || importanceNumber.value || 1),
                createdAt: (editingNote && editingNote.createdAt) || now,
              },
              editingNote ? {} : {}
            );

            let idx = notesArr.findIndex(n => n && n.id === enriched.id);
            if (idx < 0 && editingNote && !editingNote.id) {
              // Fallback: match legacy notes without id by createdAt timestamp
              idx = notesArr.findIndex(n => n && n.createdAt === editingNote.createdAt);
            }
            if (idx >= 0) notesArr[idx] = enriched; else notesArr.push(enriched);
            combined.user_notes = notesArr;

            // Gestione glossario multiplo collegato alla nota
            try {
              const gArr = Array.isArray(combined.user_glossario) ? combined.user_glossario : [];
              const prevForNote = gArr.filter(x => x && x.sourceNoteId === enriched.id);
              const oldById = new Map(prevForNote.map(x => [x.id, x]));
              let updated = gArr.filter(x => !x || x.sourceNoteId !== enriched.id);
              if (glossaryEnabled && glossaryEnabled.checked) {
                const rows = collectGlossRows();
                rows.forEach((r, i) => {
                  const existing = (r.id && oldById.get(r.id)) || null;
                  const id = r.id || (crypto.randomUUID ? crypto.randomUUID() : ('gls_' + Date.now().toString(36) + '_' + i));
                  const gNow = existing ? (existing.createdAt || now) : now;
                  const gl = {
                    id,
                    doi,
                    term: r.term || '',
                    meaning: r.meaning || '',
                    type: enriched.type || null,
                    tags: Array.isArray(enriched.tags) ? enriched.tags : [],
                    importanza: enriched.importanza,
                    createdAt: gNow,
                    sourceNoteId: enriched.id,
                  };
                  updated.push(gl);
                });
              }
              combined.user_glossario = updated;
            } catch (_) {}

            const tid = Toast ? Toast.loading('Salvataggio nota...') : null;
            await DataService.saveRecord(doi, combined);
            if (tid && Toast.update) { Toast.update(tid, 'Nota salvata', 'success'); setTimeout(()=>Toast.dismiss(tid), 600); }
            updateLoadingOverlay('Nota salvata. Aggiornamento pagina...');
            window.location.href = 'index.html';
          } catch (e) {
            console.error('Salvataggio nota fallito', e);
            if (Toast && Toast.error) Toast.error('Errore salvataggio nota');
            alert('Errore durante il salvataggio');
            hideLoadingOverlay();
          }
        }

        if (addGlossaryRow) {
          addGlossaryRow.addEventListener('click', () => {
            addGlossRow({});
            if (glossaryEnabled) glossaryEnabled.checked = true;
            const box = document.getElementById('glossaryBox');
            if (box && !box.open) box.open = true;
          });
        }

        if (prevStepBtn) prevStepBtn.addEventListener('click', () => goToStep(currentStep - 1));
        if (nextStepBtn) nextStepBtn.addEventListener('click', () => goToStep(currentStep + 1));
        stepPills.forEach(p => {
          p.addEventListener('click', () => {
            const target = Number(p.dataset.step || '1');
            goToStep(target);
          });
        });
        saveBtn.addEventListener('click', save);

        // Enhance tags select: show counts and color intensity like index filters
        function enableMultiClickToggle(selectEl) {
          if (!selectEl || selectEl.__multiToggleEnabled) return;
          selectEl.addEventListener('mousedown', (e) => {
            const t = e.target;
            if (t && t.tagName === 'OPTION') {
              e.preventDefault();
              const keep = selectEl.scrollTop;
              t.selected = !t.selected;
              const evt = new Event('change', { bubbles: true });
              selectEl.dispatchEvent(evt);
              setTimeout(() => { try { selectEl.scrollTop = keep; } catch (_) {} }, 0);
            }
          });
          selectEl.__multiToggleEnabled = true;
        }
        function computeTagsCount(db){
          const counts = {};
          try {
            const dois = Object.keys(db||{});
            for (const doi of dois){
              const entry = db[doi] || {};
              const notes = Array.isArray(entry.user_notes) ? entry.user_notes : (entry.user_note ? [entry.user_note] : []);
              for (const n of notes){
                const ts = Array.isArray(n && n.tags) ? n.tags : (n && n.tags ? [String(n.tags)] : []);
                ts.forEach(t => { const k=String(t).trim().toLowerCase(); counts[k] = (counts[k]||0)+1; });
              }
            }
          } catch (_) {}
          return counts;
        }
        function populateTagsSelectWithCounts(sel, counts){
          if (!sel) return;
          try {
            const values = Object.keys(counts||{}).sort((a,b)=> a.localeCompare(b, undefined, {sensitivity:'base'}));
            const max = values.reduce((m,v)=> Math.max(m, counts[v]||0), 0);
            sel.multiple = true; sel.size = Math.max(10, Math.min(18, values.length));
            sel.innerHTML = '';
            for (const v of values){
              const op = document.createElement('option');
              op.value = v;
              op.textContent = `${v} (${counts[v]||0})`;
              if (max > 0){
                const t = Math.max(0, Math.min(1, (counts[v]||0)/max));
                const light = 98 - Math.round(t*40); // 98 -> 58
                const sat = 85;
                op.style.background = `hsl(0 ${sat}% ${light}%)`;
                op.style.color = (light < 75) ? '#fff' : '#7f1d1d';
              }
              sel.appendChild(op);
            }
          } catch (_) {}
        }
        function syncTagsInputFromSelect(){
          const sel = document.getElementById('tagsSelect');
          const inp = document.getElementById('tagsInput');
          if (!sel || !inp) return;
          const chosen = Array.from(sel.selectedOptions).map(o=>o.value);
          const manual = (inp.value||'').split(',').map(s=>s.trim()).filter(Boolean);
          const merged = Array.from(new Set([ ...manual, ...chosen ]));
          inp.value = merged.join(', ');
          try { if (typeof renderFacetChips === 'function') renderFacetChips(); } catch(_){}
        }
        async function enhanceTagsSelect(){
          try {
            const full = await DataService.getAll();
            const counts = computeTagsCount(full);
            const sel = document.getElementById('tagsSelect');
            populateTagsSelectWithCounts(sel, counts);
            enableMultiClickToggle(sel);
            sel.addEventListener('change', syncTagsInputFromSelect);
          } catch (_) {}
        }

        applyToggleState();
        goToStep(1);
        // Init importance controls
        importanceRange.value = 1;
        importanceNumber.value = 1;
        updateImportancePreview();
        loadAll();
      })();
    </script>
  </body>
  </html>








